第1章 .NET之道
1.1 初识.NET平台
1.2 .NET平台构造块（CLR、CTS和CLS）简介
1.2.1 基础类库的作用
1.2.2 C#的优点
1.2.3 托管代码与非托管代码
1.3 其他支持.NET的编程语言
1.4 .NET程序集概览
1.4.1 CIL的作用
1.4.2 .NET类型元数据的作用
1.4.3 程序集清单的作用
1.5 CTS
1.5.1 CTS类类型
1.5.2 CTS接口类型
1.5.3 CTS结构类型
1.5.4 CTS枚举类型
1.5.5 CTS委托类型
1.5.6 CTS类型成员
1.5.7 内建的CTS数据类型
1.6 CLS
1.7 CLR
1.8 程序集/命名空间/类型的区别
1.8.1 Microsoft根命名空间的作用
1.8.2 以编程方式访问命名空间
1.8.3 引用外部程序集
1.9 使用ildasm.exe探索程序集
1.9.1 查看CIL代码
1.9.2 查看类型元数据
1.9.3 查看程序集元数据（即清单）
1.10 .NET的平台无关性
1.11 Windows 8应用程序简介
1.11.1 构建Windows 8应用程序
1.11.2 .NET在Windows 8中的作用
1.12 小结
第2章 构建C#应用程序
2.1 .NET Framework 4.5 SDK的作用
2.2 用csc.exe构建C#应用程序
2.2.1 指定输入输出目标
2.2.2 引用外部程序集
2.2.3 引用多个外部程序集
2.2.4 编译多个源文件
2.2.5 使用C#响应文件
2.3 使用Notepad++构建.NET应用程序
2.4 使用SharpDevelop构建.NET应用程序
2.5 使用Visual C# Express构建.NET应用程序
2.6 使用Visual Studio构建.NET应用程序
2.6.1 Visual Studio的独特功能
2.6.2 使用New Project对话框指向.NET Framework
2.6.3 解决方案资源管理器
2.6.4 Class View工具
2.6.5 Object Browser工具
2.6.6 集成对代码重构的支持
2.6.7 代码扩展和围绕技术
2.6.8 可视化Class Designer
2.6.9 集成的.NET Framework 4.5 SDK文档系统
2.7 小结
第3章 C#核心编程结构Ⅰ
3.1 一个简单的C#程序
3.1.1 Main方法的其他形式
3.1.2 指定应用程序错误代码
3.1.3 处理命令行参数
3.1.4 使用Visual Studio指定命令行参数
3.2 有趣的题外话：System.Environment类的其他成员
3.3 System.Console类
3.3.1 使用Console类进行基本的输入和输出
3.3.2 格式化控制台输出
3.3.3 格式化数值数据
3.3.4 在控制台应用程序外格式化数值数据
3.4 系统数据类型和相应的C#关键字
3.4.1 变量声明和初始化
3.4.2 内建数据类型与new操作符
3.4.3 数据类型类的层次结构
3.4.4 数值数据类型的成员
3.4.5 System.Boolean的成员
3.4.6 System.Char的成员
3.4.7 从字符串数据中解析数值
3.4.8 System.DateTime和System.TimeSpan
3.4.9 System.Numerics.dll程序集
3.5 使用字符串数据
3.5.1 基本的字符串操作
3.5.2 字符串拼接
3.5.3 转义字符
3.5.4 定义逐字字符串
3.5.5 字符串和相等性
3.5.6 字符串是不可变的
3.5.7 System.Text.StringBuilder类型
3.6 窄化和宽化数据类型转换
3.6.1 checked关键字
3.6.2 设定项目级别的溢出检测
3.6.3 unchecked关键字
3.7 隐式类型本地变量
3.7.1 隐式类型变量的限制
3.7.2 隐式类型数据是强类型数据
3.7.3 隐式类型本地变量的用途
3.8 C#迭代结构
3.8.1 for循环
3.8.2 foreach循环
3.8.3 while和do/while循环结构
3.9 条件结构和关系/相等操作符
3.9.1 if/else语句
3.9.2 关系/相等操作符
3.9.3 逻辑操作符
3.9.4 switch语句
3.10 小结
第4章 C#核心编程结构Ⅱ
4.1 方法和参数修饰符
4.1.1 默认的参数传递行为
4.1.2 out修饰符
4.1.3 ref修饰符
4.1.4 params修饰符
4.1.5 定义可选参数
4.1.6 使用命名参数调用方法
4.1.7 成员重载
4.2 C#数组
4.2.1 C#数组初始化语法
4.2.2 隐式类型本地数组
4.2.3 定义object数组
4.2.4 使用多维数组
4.2.5 数组作为参数（和返回值）
4.2.6 System.Array基类
4.3 枚举类型
4.3.1 控制枚举的底层存储
4.3.2 声明枚举变量
4.3.3 System.Enum类型
4.3.4 动态获取枚举的名称/值对
4.4 结构类型
4.5 值类型和引用类型
4.5.1 值类型、引用类型和赋值操作符
4.5.2 包含引用类型的值类型
4.5.3 按值传递引用类型
4.5.4 按引用传递引用类型
4.5.5 值类型和引用类型：最后的细节
4.6 C#可空类型
4.6.1 使用可空类型
4.6.2 ？？操作符
4.7 小结
第5章 封装
5.1 C#类类型
5.2 构造函数
5.2.1 默认构造函数的作用
5.2.2 定义自定义的构造函数
5.2.3 再谈默认构造函数
5.3 this关键字的作用
5.3.1 使用this进行串联构造函数调用
5.3.2 观察构造函数流程
5.3.3 再谈可选参数
5.4 static关键字
5.4.1 定义静态数据
5.4.2 定义静态方法
5.4.3 定义静态构造函数
5.4.4 定义静态类
5.5 定义OOP的支柱
5.5.1 封装的作用
5.5.2 继承的作用
5.5.3 多态的作用
5.6 C#访问修饰符
5.6.1 默认的访问修饰符
5.6.2 访问修饰符和嵌套类型
5.7 第一个支柱：C#的封装服务
5.7.1 使用传统的访问方法和修改方法执行封装
5.7.2 使用.NET属性进行封装
5.7.3 使用类的属性
5.7.4 只读和只写属性
5.7.5 静态属性
5.8 自动属性
5.8.1 与自动属性交互
5.8.2 关于自动属性和默认值
5.9 对象初始化语法
5.9.1 使用初始化语法调用自定义构造函数
5.9.2 初始化内部类型
5.10 常量数据
5.10.1 只读字段
5.10.2 静态只读字段
5.11 分部类型
5.12 小结
第6章 继承和多态
6.1 继承的基本机制
6.1.1 指定既有类的父类
6.1.2 多个基类
6.1.3 sealed关键字
6.2 回顾Visual Studio类关系图
6.3 OOP的第二个支柱：继承
6.3.1 使用base关键字控制基类的创建
6.3.2 家族的秘密：protected关键字
6.3.3 增加密封类
6.4 包含/委托编程
6.5 OOP的第三个支柱：C#的多态支持
6.5.1 virtual和override关键字
6.5.2 使用Visual Studio IDE重写虚方法
6.5.3 密封虚成员
6.5.4 抽象类
6.5.5 构建多态接口
6.5.6 成员投影
6.6 基类/派生类的转换规则
6.6.1 C#的as关键字
6.6.2 C#的is关键字
6.7 超级父类：System.Object
6.7.1 重写System.Object.ToString
6.7.2 重写System.Object.Equals
6.7.3 重写System.Object.GetHashCode
6.7.4 测试修改后的Person类
6.7.5 System.Object的静态成员
6.8 小结
第7章 结构化异常处理
7.1 错误、bug与异常
7.2 .NET异常处理的作用
7.2.1 .NET异常处理的四要素
7.2.2 System.Exception基类
7.3 最简单的例子
7.3.1 引发普通的异常
7.3.2 捕获异常
7.4 配置异常的状态
7.4.1 TargetSite属性
7.4.2 StackTrace属性
7.4.3 HelpLink属性
7.4.4 Data属性
7.5 系统级异常
7.6 应用程序级异常
7.6.1 构建自定义异常，第一部分
7.6.2 构建自定义异常，第二部分
7.6.3 构建自定义异常，第三部分
7.7 处理多个异常
7.7.1 通用的catch语句
7.7.2 再次引发异常
7.7.3 内部异常
7.7.4 finally块
7.8 谁在引发什么异常
7.9 未处理异常的后果
7.10 使用Visual Studio调试未处理的异常
7.11 小结
第8章 接口
8.1 接口类型
8.2 定义自定义接口
8.3 实现接口
8.4 在对象级别调用接口成员
8.4.1 获取接口引用：as关键字
8.4.2 获取接口引用：is关键字
8.5 接口作为参数
8.6 接口作为返回值
8.7 接口类型数组
8.8 使用Visual Studio实现接口
8.9 显式接口实现
8.10 设计接口层次结构
8.11 构建可枚举类型（IEnumerable和IEnumerator）
8.11.1 用yield关键字构建迭代器方法
8.11.2 构建命名迭代器
8.12 构建可克隆的对象（ICloneable）
8.13 构建可比较的对象（IComparable）
8.13.1 指定多个排序顺序
8.13.2 自定义属性、自定义排序类型
8.14 小结
第9章 集合与泛型
9.1 集合类的动机
9.1.1 System.Collections命名空间
9.1.2 System.Collections.Specialized命名空间
9.2 非泛型集合的问题
9.2.1 性能问题
9.2.2 类型安全问题
9.2.3 初识泛型集合
9.3 泛型类型参数的作用
9.3.1 为泛型类/结构指定类型参数
9.3.2 为泛型成员指定类型参数
9.3.3 为泛型接口指定类型参数
9.4 System.Collections.Generic命名空间
9.4.1 集合初始化语法
9.4.2 使用List类
9.4.3 使用Stack类
9.4.4 使用Queue类
9.4.5 使用SortedSet类
9.5 System.Collections.ObjectModel命名空间
9.6 创建自定义泛型方法
9.7 创建自定义泛型结构和类
9.8 类型参数的约束
9.8.1 使用where关键字的示例
9.8.2 操作符约束的不足
9.9 小结
第10章 委托、事件和Lambda表达式
10.1 .NET委托类型
10.1.1 在C#中定义委托类型
10.1.2 System.MulticastDelegate与System.Delegate基类
10.2 最简单的委托示例
10.3 使用委托发送对象状态通知
10.3.1 支持多路广播
10.3.2 从委托的调用列表中移除成员
10.3.3 方法组转换语法
10.4 泛型委托
10.5 C#事件
10.5.1 event关键字
10.5.2 揭开事件的神秘面纱
10.5.3 监听传入的事件
10.5.4 使用Visual Studio简化事件注册
10.5.5 创建自定义的事件参数
10.5.6 泛型EventHandler委托
10.6 C#匿名方法
10.7 Lambda表达式
10.7.1 剖析Lambda表达式
10.7.2 使用多个语句处理参数
10.7.3 含有多个（或零个）参数的Lambda表达式
10.7.4 使用Lambda表达式重新编写CarEvents示例
10.8 小结
第11章 高级C#语言特性
11.1 索引器方法
11.1.1 使用字符串值索引对象
11.1.2 重载索引器方法
11.1.3 多维的索引器
11.1.4 在接口类型上定义索引器
11.2 操作符重载
11.2.1 重载二元操作符
11.2.2 +=与-=操作符
11.2.3 重载一元操作符
11.2.4 重载相等操作符
11.2.5 重载比较操作符
11.2.6 操作符重载的最后思考
11.3 自定义类型转换
11.3.1 回顾：数值转换
11.3.2 回顾：相关的类类型间的转换
11.3.3 创建自定义转换例程
11.3.4 Square类型的其他显式转换
11.3.5 定义隐式转换例程
11.4 扩展方法
11.4.1 定义扩展方法
11.4.2 在实例层次上调用扩展方法
11.4.3 导入扩展方法
11.4.4 扩展方法的智能感知
11.4.5 扩展实现了指定接口的类型
11.5 匿名类型
11.5.1 定义匿名类型
11.5.2 匿名类型的内部表示方式
11.5.3 方法ToString和GetHashCode的实现
11.5.4 匿名类型的相等语义
11.5.5 包含匿名类型的匿名类型
11.6 指针类型
11.6.1 unsafe关键字
11.6.2 *和&操作符
11.6.3 不安全（与安全）交换功能
11.6.4 通过指针访问字段
11.6.5 stackalloc关键字
11.6.6 使用fixed关键字固定类型
11.6.7 sizeof关键字
11.7 小结
第12章 LINQ to Object
12.1 LINQ特有的编程结构
12.1.1 隐式类型本地变量
12.1.2 对象和集合初始化语法
12.1.3 Lambda表达式
12.1.4 扩展方法
12.1.5 匿名类型
12.2 LINQ的作用
12.2.1 LINQ表达式是强类型的
12.2.2 核心LINQ程序集
12.3 将LINQ查询应用于原始数组
12.3.1 再一次，不使用LINQ
12.3.2 反射LINQ结果集
12.3.3 LINQ和隐式类型本地变量
12.3.4 LINQ和扩展方法
12.3.5 延迟执行的作用
12.3.6 立即执行的作用
12.4 返回LINQ查询的结果
12.5 将LINQ查询应用到集合对象
12.5.1 访问包含的子对象
12.5.2 将LINQ查询应用于非泛型集合
12.5.3 使用OfType筛选数据
12.6 C# LINQ查询操作符
12.6.1 基本的选择语法
12.6.2 获取数据子集
12.6.3 投影新数据类型
12.6.4 使用Enumerable获取总数
12.6.5 反转结果集
12.6.6 对表达式进行排序
12.6.7 维恩图工具
12.6.8 移除重复
12.6.9 LINQ聚合操作
12.7 LINQ查询语句的内部表示
12.7.1 用查询操作符建立查询表达式（复习）
12.7.2 使用Enumerable类型和Lambda表达式来建立查询表达式
12.7.3 使用Enumerable类型和匿名方法来建立查询表达式
12.7.4 用Enumerable类型和原始委托建立查询表达式
12.8 小结
第13章 对象的生命周期
13.1 类、对象和引用
13.2 对象生命周期的基础
13.2.1 CIL的new指令
13.2.2 将对象引用设置为空
13.3 应用程序根的作用
13.4 对象的代
13.5 .NET 1.0至.NET 3.5的并发垃圾回收
13.6 .NET 4.0及后续版本
13.7 System.GC类型
13.8 构建可终结对象
13.8.1 重写System.Object.Finalize
13.8.2 终结过程的细节
13.9 构建可处置对象
13.10 构建可终结类型和可处置类型
13.11 延迟对象实例化
13.12 小结
第14章 .NET程序集入门
14.1 定义自定义命名空间
14.1.1 使用完全限定名解决命名冲突
14.1.2 使用别名解决命名冲突
14.1.3 创建嵌套的命名空间
14.1.4 Visual Studio 的默认命名空间
14.2 .NET程序集的作用
14.2.1 程序集促进代码重用
14.2.2 程序集确定类型边界
14.2.3 程序集是可版本化的单元
14.2.4 程序集是自描述的
14.2.5 程序集是可配置的
14.3 .NET程序集的格式
14.3.1 Windows文件首部
14.3.2 CLR文件首部
14.3.3 CIL代码、类型元数据和程序集清单
14.3.4 可选的程序集资源
14.4 构建和使用自定义类库
14.4.1 清单
14.4.2 CIL
14.4.3 类型元数据
14.4.4 构建C#客户端应用程序
14.4.5 构建Visual Basic客户端应用程序
14.4.6 实现跨语言继承
14.5 私有程序集
14.5.1 私有程序集的标识
14.5.2 探测过程
14.5.3 配置私有程序集
14.5.4 App.Config文件
14.6 共享程序集
14.6.1 全局程序集缓存
14.6.2 强名称
14.6.3 在命令行生成强名称
14.6.4 使用Visual Studio为程序集赋予强名称
14.6.5 在GAC中安装强名称的程序集
14.7 使用共享程序集
14.8 配置共享程序集
14.8.1 冻结当前的共享程序集
14.8.2 构建共享程序集2.0.0.0版本
14.8.3 动态重定向到共享程序集的特定版本
14.9 发行者策略程序集
14.10 元素
14.11 System.Configuration命名空间
14.12 配置文件架构文档
14.13 小结
第15章 类型反射、晚期绑定和基于特性的编程
15.1 类型元数据的必要性
15.1.1 查看（部分）EngineState枚举的元数据
15.1.2 查看（部分）Car类型的元数据
15.1.3 研究TypeRef
15.1.4 记录定义的程序集
15.1.5 记录引用的程序集
15.1.6 记录字符串字面量
15.2 反射
15.2.1 System.Type类
15.2.2 使用System.Object.GetType得到Type引用
15.2.3 使用typeof得到Type引用
15.2.4 使用System.Type.GetType得到Type引用
15.3 构建自定义的元数据查看器
15.3.1 反射方法
15.3.2 反射字段和属性
15.3.3 反射实现的接口
15.3.4 显示其他信息
15.3.5 实现Main
15.3.6 反射泛型类型
15.3.7 反射方法参数和返回值
15.4 动态加载程序集
15.5 反射共享程序集
15.6 晚期绑定
15.6.1 System.Activator类
15.6.2 调用没有参数的方法
15.6.3 调用有参数的方法
15.7 .NET特性的作用
15.7.1 特性的使用者
15.7.2 在C#中使用特性
15.7.3 C#特性简化符号
15.7.4 为特性指定构造参数
15.7.5 Obsolete特性
15.8 构建自定义特性
15.8.1 应用自定义特性
15.8.2 命名属性语法
15.8.3 限制特性使用
15.9 程序集级别特性
15.10 使用早期绑定反射特性
15.11 使用晚期绑定反射特性
15.12 反射、晚期绑定和自定义特性的使用背景
15.13 构建可扩展的应用程序
15.13.1 构建CommonSnappable-Types.dll
15.13.2 构建C#插件
15.13.3 构建Visual Basic插件
15.13.4 构建可扩展的Windows Forms应用程序
15.14 小结
第16章 动态类型和动态语言运行时
16.1 dynamic关键字的作用
16.1.1 调用动态声明的数据的成员
16.1.2 Microsoft.CSharp.dll程序集的作用
16.1.3 dynamic关键字的作用域
16.1.4 dynamic关键字的限制
16.1.5 dynamic关键字的实际用途
16.2 DLR的作用
16.2.1 表达式树的作用
16.2.2 System.Dynamic命名空间的作用
16.2.3 表达式树的动态运行时查找
16.3 使用动态类型简化后期绑定调用
16.4 使用动态数据简化COM互操作
16.4.1 主互操作程序集的作用
16.4.2 嵌入互操作元数据
16.4.3 普通COM互操作的难点
16.5 使用C# 动态数据进行COM互操作
16.6 不使用C# 动态数据进行COM互操作
16.7 小结
第17章 进程、应用程序域和对象上下文
17.1 Windows进程的作用
17.2 .NET平台下与进程进行交互
17.2.1 列举运行中的进程
17.2.2 特定的进程
17.2.3 进程的线程集合
17.2.4 进程中的模块集合
17.2.5 以编程方式启动或结束进程
17.2.6 使用ProcessStartInfo类控制进程的启动
17.3 .NET应用程序域
17.4 与默认应用程序域进行交互
17.4.1 枚举加载的程序集
17.4.2 接收程序集加载通知
17.5 创建新的应用程序域
17.5.1 在自定义应用程序域中加载程序集
17.5.2 以编程方式卸载应用程序域
17.6 对象上下文边界
17.6.1 上下文灵活和上下文绑定类型
17.6.2 定义上下文绑定对象
17.6.3 研究对象的上下文
17.7 进程、应用程序域和上下文小结
17.8 小结
第18章 CIL和动态程序集的作用
18.1 学习CIL语法的原因
18.2 CIL指令、特性和操作码
18.2.1 CIL指令的作用
18.2.2 CIL特性的作用
18.2.3 CIL操作码的作用
18.2.4 区别CIL操作码和CIL助记符
18.3 入栈和出栈：CIL基于栈的本质
18.4 正反向工程
18.4.1 CIL代码标签的作用
18.4.2 与CIL交互：修改*.il文件
18.4.3 使用ilasm.exe编译CIL代码
18.4.4 peverify.exe的作用
18.5 CIL指令和特性
18.5.1 在CIL中指定外部引用程序集
18.5.2 在CIL中定义当前程序集
18.5.3 在CIL中定义命名空间
18.5.4 在CIL中定义类类型
18.5.5 在CIL中定义和实现接口
18.5.6 在CIL中定义结构
18.5.7 在CIL中定义枚举
18.5.8 在CIL中定义泛型
18.5.9 编译CILTypes.il文件
18.6 .NET基础类库、C#和CIL数据类型的映射
18.7 在CIL中定义类型成员
18.7.1 在CIL中定义数据字段
18.7.2 在CIL中定义类型的构造函数
18.7.3 在CIL中定义属性
18.7.4 定义成员参数
18.8 剖析CIL操作码
18.8.1 .maxstack指令
18.8.2 在CIL中声明本地变量
18.8.3 在CIL中映射参数到本地变量
18.8.4 this隐式引用
18.8.5 在CIL中使用循环结构
18.9 使用CIL构建.NET程序集
18.9.1 构建CILCars.dll
18.9.2 构建CILCarClient.exe
18.10 动态程序集
18.10.1 System.Reflection.Emit命名空间
18.10.2 System.Reflection.Emit.ILGenerator的作用
18.10.3 产生动态的程序集
18.10.4 产生程序集和模块集
18.10.5 ModuleBuilder类型的作用
18.10.6 产生HelloClass类型和字符串成员变量
18.10.7 产生构造函数
18.10.8 产生SayHello方法
18.10.9 使用动态产生的程序集
18.11 小结
第19章 多线程、并行和异步编程
19.1 进程、应用程序域、上下文及线程之间的关系
19.1.1 并发问题
19.1.2 线程同步的作用
19.2 .NET委托的简短回顾
19.3 委托的异步性
19.3.1 BeginInvoke和EndInvoke方法
19.3.2 System.IAsyncResult接口
19.4 异步调用方法
19.4.1 同步调用线程
19.4.2 AsyncCallback委托的作用
19.4.3 AsyncResult类的作用
19.4.4 传递和接收自定义状态数据
19.5 System.Threading命名空间
19.6 System.Threading.Thread类
19.6.1 获得当前执行线程的统计信息
19.6.2 Name属性
19.6.3 Priority属性
19.7 手工创建次线程
19.7.1 使用ThreadStart委托
19.7.2 使用ParameterizedThreadStart委托
19.7.3 AutoResetEvent类
19.7.4 前台线程和后台线程
19.8 并发问题
19.8.1 使用C#的lock关键字进行同步
19.8.2 使用System.Threading.Monitor类型进行同步
19.8.3 使用System.Threading.Interlocked类型进行同步
19.8.4 使用[Synchronization]特性进行同步
19.9 使用TimerCallback编程
19.10 CLR线程池
19.11 使用任务并行库进行并行编程
19.11.1 任务并行库API
19.11.2 Parallel类的作用
19.11.3 使用Parallel类的数据并行
19.11.4 在次线程中访问UI元素
19.11.5 Task类
19.11.6 处理取消请求
19.11.7 使用并行类的任务并行
19.12 并行LINQ查询（PLINQ）
19.12.1 使用PLINQ查询
19.12.2 取消PLINQ查询
19.13 .NET 4.5下的异步调用
19.13.1 C# async和await关键字初探
19.13.2 异步方法的命名约定
19.13.3 返回void的异步方法
19.13.4 具有多个await的异步方法
19.13.5 用async/await改进AddWithThreads示例
19.14 小结
第20章 文件输入输出和对象序列化
20.1 研究System.IO命名空间
20.2 Directory（Info）和File（Info）类型
20.3 使用DirectoryInfo类型
20.3.1 使用DirectoryInfo类型枚举出文件
20.3.2 使用DirectoryInfo类型创建子目录
20.4 使用Directory类型
20.5 使用DriveInfo类类型
20.6 使用FileInfo类
20.6.1 FileInfo.Create方法
20.6.2 FileInfo.Open方法
20.6.3 FileInfo.OpenRead和FileInfo.OpenWrite方法
20.6.4 FileInfo.OpenText方法
20.6.5 FileInfo.CreateText和FileInfo.AppendText方法
20.7 使用File类型
20.8 Stream抽象类
20.9 使用StreamWriter和StreamReader类型
20.9.1 写文本文件
20.9.2 读文本文件
20.9.3 直接创建StreamWriter/StreamReader类型
20.10 使用StringWriter和StringReader类型
20.11 使用BinaryWriter和BinaryReader
20.12 以编程方式“观察”文件
20.13 对象序列化
20.14 为序列化配置对象
20.14.1 定义可序列化的类型
20.14.2 公共字段、私有字段和公共属性
20.15 选择序列化格式化程序
20.15.1 IFormatter和IRemoting-Formatting接口
20.15.2 在格式化程序中的类型保真
20.16 使用BinaryFormatter序列化对象
20.17 使用SoapFormatter序列化对象
20.18 使用XmlSerializer序列化对象
20.19 序列化对象集合
20.20 自定义Soap/Binary序列化过程
20.20.1 深入了解对象序列化
20.20.2 使用ISerializable自定义序列化
20.20.3 使用特性定制序列化
20.21 小结
第21章 ADO.NET之一：连接层
21.1 ADO.NET的宏观定义
21.2 ADO.NET数据提供程序
21.2.1 微软提供的ADO.NET数据提供程序
21.2.2 关于System.Data.Oracle-Client.dll
21.2.3 选择第三方的数据提供程序
21.3 其他的ADO.NET命名空间
21.4 System.Data命名空间的类型
21.4.1 IDbConnection接口的作用
21.4.2 IDbTransaction接口的作用
21.4.3 IDbCommand接口的作用
21.4.4 IDbDataParameter和IDataParameter接口的作用
21.4.5 IDbDataAdapter和IDataAdapter接口的作用
21.4.6 IDataReader和IDataRecord接口的作用
21.5 使用接口的抽象数据提供程序
21.6 创建AutoLot数据库
21.6.1 创建Inventory表
21.6.2 为Inventory表添加测试记录
21.6.3 编写GetPetName存储过程
21.6.4 创建Customers和Orders表
21.6.5 可视化创建表关系
21.7 ADO.NET数据提供程序工厂模型
21.7.1 完整的数据提供程序工厂的例子
21.7.2 数据提供程序工厂模型的潜在缺陷
21.7.3 元素
21.8 ADO.NET的连接层
21.8.1 使用连接对象
21.8.2 使用ConnectionStringBuilder对象
21.8.3 使用命令对象
21.9 使用数据读取器
21.10 构建可重用的数据访问库
21.10.1 增加连接逻辑
21.10.2 增加插入逻辑
21.10.3 增加删除逻辑
21.10.4 增加更新逻辑
21.10.5 增加选择逻辑
21.10.6 使用参数化的命令对象
21.10.7 执行存储过程
21.11 创建控制台UI前端
21.11.1 实现Main方法
21.11.2 实现ShowInstructions方法
21.11.3 实现ListInventory方法
21.11.4 实现DeleteCar方法
21.11.5 实现InsertNewCar方法
21.11.6 实现UpdateCarPetName方法
21.11.7 实现LookUpPetName
21.12 数据库事务
21.12.1 ADO.NET事务对象的主要成员
21.12.2 为AutoLot数据库添加CreditRisks表
21.12.3 为InventoryDAL添加事物方法
21.12.4 测试数据库事务
21.13 小结
第22章 ADO.NET之二：断开连接层
22.1 ADO.NET断开连接层
22.2 DataSet的作用
22.2.1 DataSet的主要属性
22.2.2 DataSet的主要方法
22.2.3 构建DataSet
22.3 使用DataColumn
22.3.1 构建DataColumn
22.3.2 启用自增列
22.3.3 把DataColumn对象加入DataTable
22.4 使用DataRow
22.4.1 RowState属性
22.4.2 DataRowVersion属性
22.5 使用DataTable
22.5.1 将DataTable插入到DataSet中
22.5.2 获取DataSet中的数据
22.5.3 使用DataTableReader对象处理DataTable
22.5.4 序列化DataTable/DataSet对象为XML
22.5.5 以二进制格式序列化Data-Table/DataSet对象
22.6 将DataTable对象绑定到用户界面
22.6.1 从泛型List合成DataTable
22.6.2 从DataTable中删除行
22.6.3 根据筛选条件选择行
22.6.4 在DataTable中更新行
22.6.5 使用DataView类型
22.7 使用数据适配器
22.7.1 一个简单的数据适配器示例
22.7.2 映射数据库名称为友好名称
22.8 向AutoLotDAL.dll添加断开连接功能
22.8.1 定义初始类类型
22.8.2 使用SqlCommandBuilder来配置数据适配器
22.8.3 实现GetAllInventory
22.8.4 实现UpdateInventory
22.8.5 设置版本号
22.8.6 测试非连接的功能
22.9 多表DataSet对象和数据关系
22.9.1 建立数据适配器
22.9.2 建立表间关系
22.9.3 更新Database表
22.9.4 在关联表中切换
22.10 Windows Forms数据库设计器工具
22.10.1 可视化设计DataGridView
22.10.2 生成的App.config文件
22.10.3 强类型的DataSet
22.10.4 强类型的DataTable
22.10.5 强类型的DataRow
22.10.6 强类型的数据适配器
22.10.7 完成Windows Forms应用程序
22.11 将强类型的数据库代码隔离到类库中
22.11.1 查看生成的代码
22.11.2 用生成的代码选择数据
22.11.3 用生成的代码插入数据
22.11.4 用生成的代码删除数据
22.11.5 用生成的代码调用存储过程
22.12 LINQ to DataSet
22.12.1 DataSet Extensions库的作用
22.12.2 获取与LINQ兼容的DataTable
22.12.3 DataRowExtensions.Field-扩展方法的作用
22.12.4 从LINQ查询中生成新的DataTable
22.13 小结
第23章 ADO.NET之三：Entity Framework
23.1 Entity Framework的作用
23.1.1 实体的作用
23.1.2 Entity Framework的基础知识
23.2 创建和分析EDM
23.3 对概念模型进行编程
23.4 AutoLotDAL 4.0版，加入实体
23.4.1 导航属性的作用
23.4.2 在LINQ to Entity查询中使用导航属性
23.4.3 调用存储过程
23.5 将数据实体绑定到Windows Forms GUI
23.6 展望.NET数据访问API的未来
23.7 小结
第24章 LINQ to XML简介
24.1 两个XML API的故事
24.1.1 更优秀的DOM——LINQ to XML
24.1.2 更优秀的LINQ to XML——VB字面量语法
24.2 System.Xml.Linq命名空间的成员
24.2.1 LINQ to XML的轴方法
24.2.2 奇妙的XName和XNamespace
24.3 使用XElement和XDocument
24.3.1 从数组和容器中生成文档
24.3.2 加载和解析XML内容
24.4 在内存中操作XML文档
24.4.1 构建LINQ to XML应用程序的UI
24.4.2 引入Inventory.xml文件
24.4.3 定义LINQ to XML辅助类
24.4.4 将UI组装到辅助类
24.5 小结
第25章 WCF
25.1 各种分布式计算API
25.1.1 DCOM的作用
25.1.2 COM+/企业服务的作用
25.1.3 MSMQ的作用
25.1.4 .NET Remoting的作用
25.1.5 XML Web服务的作用
25.2 WCF的作用
25.2.1 WCF特性概览
25.2.2 SOA概览
25.2.3 WCF概要
25.3 WCF核心程序集
25.4 Visual Studio WCF项目模板
25.5 WCF应用程序的基本构成
25.6 WCF的ABC
25.6.1 WCF契约
25.6.2 WCF绑定
25.6.3 WCF地址
25.7 构建WCF服务
25.7.1 [ServiceContract]特性
25.7.2 [OperationContract]特性
25.7.3 作为操作契约的服务类型
25.8 承载WCF服务
25.8.1 在App.config文件中创建ABC
25.8.2 针对ServiceHost类型进行编程
25.8.3 指定库地址
25.8.4 ServiceHost类型的功能
25.8.5 元素的细节
25.8.6 启用元数据交换
25.9 构建WCF客户端应用程序
25.9.1 使用svcutil.exe生成代理代码
25.9.2 使用Visual Studio生成代理代码
25.9.3 配置基于TCP的绑定
25.10 简化配置设置
25.10.1 使用默认终结点
25.10.2 使用多重绑定公开单独的WCF服务
25.10.3 修改WCF绑定的设置
25.10.4 使用默认的MEX行为配置
25.10.5 刷新客户端代理和选择绑定
25.11 使用WCF服务库项目模板
25.11.1 构建简单的Math服务
25.11.2 使用WcfTestClient.exe测试WCF服务
25.11.3 使用SvcConfigEditor.exe修改配置文件
25.12 以Windows服务承载WCF服务
25.12.1 在代码中指定ABC
25.12.2 启用MEX
25.12.3 创建Windows服务安装程序
25.12.4 安装Windows服务
25.13 从客户端异步调用服务
25.14 定义WCF数据契约
25.14.1 使用Web相关的WCF服务项目模板
25.14.2 实现服务契约
25.14.3 *.svc文件的作用
25.14.4 更新web.config文件
25.14.5 测试服务
25.15 小结
第26章 Windows Workflow Foundation简介
26.1 定义业务流程
26.2 构建简单的工作流
26.3 Workflow运行时
26.3.1 使用WorkflowInvoker承载工作流
26.3.2 使用WorkflowApplication承载工作流
26.3.3 第一个工作流示例回顾
26.4 检查Workflow中的活动
26.4.1 控制流活动
26.4.2 流程图活动
26.4.3 消息传递活动
26.4.4 状态机活动
26.4.5 运行时活动与基元活动
26.4.6 事务活动
26.4.7 集合活动和错误处理活动
26.5 构建流程图工作流
26.5.1 在流程图中连接活动
26.5.2 使用InvokeMethod活动
26.5.3 定义工作流变量
26.5.4 使用FlowDecision活动
26.5.5 使用TerminateWorkflow活动
26.5.6 构建“true”条件
26.5.7 使用ForEach活动
26.5.8 完成应用程序
26.5.9 我们做了什么
26.6 在专门的DLL中构建Squence工作流
26.6.1 定义初始化项目
26.6.2 引入程序集和命名空间
26.6.3 定义工作流参数
26.6.4 定义工作流变量
26.6.5 使用Assign活动
26.6.6 使用If和Switch活动
26.6.7 构建自定义代码活动
26.7 使用工作流库
26.8 小结
第27章 WPF和XAML
27.1 WPF背后的动机
27.1.1 统一多种不同的API
27.1.2 通过XAML将关注点分离
27.1.3 提供优化的呈现模型
27.1.4 简化复杂的UI编程
27.2 各种形式的WPF应用程序
27.2.1 传统的桌面应用程序
27.2.2 基于导航的WPF应用程序
27.2.3 XBAP应用程序
27.2.4 WPF/Silverlight关系
27.3 WPF程序集
27.3.1 Application类的作用
27.3.2 Window类的作用
27.4 创建不使用XAML的WPF应用程序
27.4.1 创建强类型的Window类
27.4.2 创建简单的用户界面
27.4.3 与应用程序级别的数据交互
27.4.4 处理Window对象的关闭
27.4.5 拦截鼠标事件
27.4.6 拦截键盘事件
27.5 仅使用XAML构建WPF应用程序
27.5.1 用XAML定义窗体对象
27.5.2 用XAML定义应用对象
27.5.3 通过msbuild.exe处理XAML文件
27.6 将标记转换为.NET程序集
27.6.1 将窗口XAML标记映射到C#代码
27.6.2 BAML的作用
27.6.3 将应用程序XAML标记映射到C#代码
27.6.4 XAML到程序集的过程摘要
27.7 WPF XAML语法
27.7.1 Kaxaml
27.7.2 XAML XML命名空间和XAML关键字
27.7.3 控制类和成员变量的可见性
27.7.4 XAML元素、XAML特性和类型转换器
27.7.5 XAML属性元素语法
27.7.6 XAML附加属性
27.7.7 XAML标记扩展
27.8 使用代码隐藏文件构建WPF应用程序
27.8.1 为MainWindow类添加代码文件
27.8.2 为MyApp类添加代码文件
27.8.3 用msbuild.exe处理代码文件
27.9 使用Visual Studio构建WPF应用程序
27.9.1 WPF项目模板
27.9.2 工具箱和XAML设计器/编辑器
27.9.3 使用Properties窗口设置属性
27.9.4 使用Properties窗口处理事件
27.9.5 在XAML编辑器中处理事件
27.9.6 Document Outline窗口
27.9.7 查看自动生成的代码文件
27.10 使用Visual Studio构建自定义XAML编辑器
27.10.1 设计窗口的GUI
27.10.2 实现Loaded事件
27.10.3 实现按钮的Click事件
27.10.4 实现Closed事件
27.10.5 测试应用程序
27.10.6 探索WPF 文档
27.11 小结
第28章 使用WPF控件编程
28.1 WPF核心控件概述
28.1.1 WPF Ink控件
28.1.2 WPF Document控件
28.1.3 WPF公共对话框
28.1.4 文档中的细节
28.2 Visual Studio WPF设计器
28.2.1 在Visual Studio中使用WPF控件
28.2.2 使用Document Outline编辑器
28.3 使用面板控制内容布局
28.3.1 在Canvas面板中放置内容
28.3.2 在WrapPanel面板中放置内容
28.3.3 在StackPanel面板中放置内容
28.3.4 在Grid面板中放置内容
28.3.5 在DockPanel面板中放置内容
28.3.6 启用Panel类型的滚动功能
28.3.7 使用Visual Studio设计器配置Panel
28.4 使用嵌套面板构建窗口框架
28.4.1 构建菜单系统
28.4.2 构建工具条
28.4.3 构建状态条
28.4.4 完成UI设计
28.4.5 实现MouseEnter/MouseLeave事件处理程序
28.4.6 实现拼写检查逻辑
28.5 WPF命令
28.5.1 内置的命令对象
28.5.2 将命令连接到Command属性
28.5.3 将命令连接到任意行为
28.5.4 使用Open和Save命令
28.6 深入了解WPF API和控件
28.7 构建Ink API选项卡
28.7.1 设计工具条
28.7.2 RadioButton控件
28.7.3 处理Ink API选项卡的事件
28.7.4 InkCanvas控件
28.7.5 ComboBox控件
28.7.6 保存、加载和清除InkCanvas数据
28.8 Documents API
28.8.1 块元素和内联元素
28.8.2 文档布局管理器
28.9 构建Documents选项卡
28.9.1 使用代码填充FlowDocument
28.9.2 启用批注和便签
28.9.3 保存和加载流文档
28.10 WPF数据绑定模型
28.10.1 构建Data Binding选项卡
28.10.2 使用Visual Studio建立数据绑定
28.10.3 DataContext属性
28.10.4 使用IValueConverter进行数据转换
28.10.5 在代码中建立数据绑定
28.10.6 构建DataGrid选项卡
28.11 小结
第29章 WPF图形呈现服务
29.1 理解WPF的图形呈现服务
29.2 使用形状呈现图形数据
29.2.1 在画布中添加矩形、椭圆形和线条
29.2.2 在画布中移除矩形、圆形和线条
29.2.3 折线和多边形
29.2.4 路径
29.3 WPF画刷和画笔
29.3.1 使用Visual Studio配置画刷
29.3.2 在代码中配置画刷
29.3.3 配置画笔
29.4 图形变换
29.4.1 变换概览
29.4.2 变换Canvas数据
29.5 使用Visual Studio变换编辑器
29.5.1 构建初始布局
29.5.2 在设计时应用变换
29.5.3 在代码中变换画布
29.6 使用绘图和几何图形呈现图形数据
29.6.1 使用几何图形构建DrawingBrush
29.6.2 用DrawingBrush进行绘画
29.6.3 在DrawingImage中使用绘图类型
29.7 Expression Design的作用
29.7.1 将示例设计文件导出为XAML
29.7.2 将图像数据导入WPF对象
29.7.3 与熊共舞
29.8 使用可视化层呈现图形数据
29.9 小结
第30章 WPF资源、动画和样式
30.1 理解WPF资源系统
30.2 使用对象（逻辑）资源
30.2.1 Resources属性的作用
30.2.2 定义窗口级别的资源
30.2.3 {StaticResource}标记扩展
30.2.4 {DynamicResource}标记扩展
30.2.5 应用程序级别的资源
30.2.6 定义合并的资源字典
30.2.7 定义只含资源的程序集
30.3 理解WPF动画服务
30.3.1 动画类型的作用
30.3.2 To、From和By属性
30.3.3 Timeline基类的作用
30.3.4 用C#代码创建动画
30.3.5 控制动画的速度
30.3.6 动画的反转和循环
30.4 用XAML创建动画
30.4.1 演示图板的作用
30.4.2 事件触发器的作用
30.4.3 使用不连续的关键帧创建动画
30.5 WPF样式的作用
30.5.1 定义并使用样式
30.5.2 重写样式设置
30.5.3 使用TargetType自动应用样式
30.5.4 继承已有的样式
30.5.5 未命名样式的作用
30.5.6 使用触发器定义样式
30.5.7 使用多个触发器定义样式
30.5.8 动画样式
30.5.9 以编程方式设置样式
30.6 小结
第31章 依赖属性、路由事件和模板
31.1 依赖属性的作用
31.1.1 已知的依赖属性
31.1.2 CLR属性包装器的重要说明
31.2 构建自定义依赖属性
31.2.1 添加数据验证例程
31.2.2 响应属性的改变
31.3 路由事件
31.3.1 路由冒泡事件的作用
31.3.2 继续或中止冒泡
31.3.3 路由隧道事件的作用
31.4 逻辑树、可视树和默认模板
31.4.1 以编程方式查看逻辑树
31.4.2 以编程方式查看可视树
31.4.3 以编程方式查看控件的默认模板
31.5 使用触发器框架构建自定义控件模板
31.5.1 模板资源
31.5.2 使用触发器添加可视提示
31.5.3 {TemplateBinding}标记扩展的作用
31.5.4 ContentPresenter的作用
31.5.5 融合模板和样式
31.6 小结
第32章 ASP.NET Web Form
32.1 HTTP的作用
32.1.1 HTTP请求/响应循环
32.1.2 HTTP是无状态协议
32.2 Web应用程序和Web服务器
32.2.1 IIS虚拟目录的作用
32.2.2 ASP.NET Development Web Server
32.3 HTML的作用
32.3.1 HTML文档结构
32.3.2 HTML表单的作用
32.3.3 Visual Studio HTML设计器工具
32.3.4 构建HTML表单
32.4 客户端脚本的作用
32.5 回发到Web服务器
32.6 ASP.NET API概览
32.6.1 ASP.NET 2.0及其后续版本的主要特性
32.6.2 ASP.NET 3.5（和.NET 3.5 SP1）的主要特性
32.6.3 ASP.NET 4.0和4.5的主要特性
32.7 构建单个文件的ASP.NET网页
32.7.1 引用AutoLotDAL.dll
32.7.2 设计UI
32.7.3 添加数据访问逻辑
32.7.4 ASP.NET指令的作用
32.7.5 脚本块
32.7.6 ASP.NET控件声明
32.8 使用代码文件构建ASP.NET Web页面
32.8.1 引用AutoLotDAL.dll程序集
32.8.2 更新代码文件
32.8.3 调试并跟踪ASP.NET页面
32.9 ASP.NET Web Site和ASP.NET Web Application
32.10 ASP.NET网站目录结构
32.10.1 引用程序集
32.10.2 App_Code文件夹的作用
32.11 页面类型的继承链
32.12 与传入的HTTP请求交互
32.12.1 获得浏览器统计数据
32.12.2 访问传入的表单数据
32.12.3 IsPostBack属性
32.13 与输出HTTP响应交互
32.13.1 提交HTML内容
32.13.2 重定向用户
32.14 ASP.NET网页的生命周期
32.14.1 AutoEventWireUp特性的作用
32.14.2 Error事件
32.15 web.config文件的作用
32.16 小结
第33章 ASP.NET Web控件、母版页和主题
33.1 Web控件的本质
33.1.1 服务器端事件处理
33.1.2 AutoPostBack属性
33.2 Control和WebControl基类
33.2.1 枚举所包含的控件
33.2.2 动态添加和删除控件
33.2.3 与动态创建的控件交互
33.2.4 WebControl基类的功能
33.3 ASP.NET Web控件的类别
33.3.1 关于System.Web.UI.HtmlControls的简短说明
33.3.2 Web控件的文档
33.4 构建ASP.NET汽车网站
33.4.1 使用ASP.NET母版页工作
33.4.2 定义默认的内容页面
33.4.3 设计Inventory内容页面
33.4.4 设计Build-a-Car内容页面
33.5 验证控件的作用
33.5.1 开启客户端JavaScript验证支持
33.5.2 RequiredFieldValidator
33.5.3 RegularExpressionValidator
33.5.4 RangeValidator
33.5.5 CompareValidator
33.5.6 创建ValidationSummary
33.5.7 定义验证分组
33.6 使用主题
33.6.1 *.skin文件
33.6.2 应用网站级别的主题
33.6.3 在页面级别应用主题
33.6.4 SkinID属性
33.6.5 以编程方式分配主题
33.7 小结
第34章 ASP.NET状态管理技术
34.1 状态问题
34.2 ASP.NET状态管理技术
34.3 ASP.NET视图状态的作用
34.3.1 演示视图状态
34.3.2 添加自定义视图状态数据
34.4 Global.asax文件的作用
34.4.1 全局最后异常事件处理程序
34.4.2 HttpApplication基类
34.5 应用程序状态与会话状态的差别
34.5.1 维护应用程序级的状态数据
34.5.2 修改应用程序数据
34.5.3 处理Web应用程序的关闭
34.6 使用应用程序缓存
34.6.1 使用数据缓存
34.6.2 修改*.aspx文件
34.7 维护会话数据
34.8 cookie
34.8.1 创建cookie
34.8.2 读取传入的cookie数据
34.9 元素的作用
34.9.1 在ASP.NET会话状态服务器中保存会话数据
34.9.2 把会话数据保存在专门的数据库中
34.10 ASP.NET用户配置API
34.10.1 ASPNETDB.mdf数据库
34.10.2 在web.config中定义用户配置
34.10.3 以编程方式访问用户配置数据
34.10.4 分组用户配置数据并且持久化自定义对象
34.11 小结