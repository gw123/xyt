第1章 HTTP概述
1.1 HTTP——因特网的多媒体信使
1.2 Web客户端和服务器
1.3 资源
1.3.1 媒体类型
1.3.2 URI
1.3.3 URL
1.3.4 URN
1.4 事务
1.4.1 方法
1.4.2 状态码
1.4.3 Web页面中可以包含多个对象
1.5 报文
1.6 连接
1.6.1 TCP/IP
1.6.2 连接、IP地址及端口号
1.6.3 使用Telnet实例
1.7 协议版本
1.8 Web的结构组件
1.8.1 代理
1.8.2 缓存
1.8.3 网关
1.8.4 隧道
1.8.5 Agent代理
1.9 起始部分的结束语
1.10 更多信息
1.10.1 HTTP协议信息
1.10.2 历史透视
1.10.3 其他万维网信息
第2章 URL与资源
2.1 浏览因特网资源
2.2 URL的语法
2.2.1 方案——使用什么协议
2.2.2 主机与端口
2.2.3 用户名和密码
2.2.4 路径
2.2.5 参数
2.2.6 查询字符串
2.2.7 片段
2.3 URL快捷方式
2.3.1 相对URL
2.3.2 自动扩展URL
2.4 各种令人头疼的字符
2.4.1 URL字符集
2.4.2 编码机制
2.4.3 字符限制
2.4.4 另外一点说明
2.5 方案的世界
2.6 未来展望
2.7 更多信息
第3章 HTTP报文
3.1 报文流
3.1.1 报文流入源端服务器
3.1.2 报文向下游流动
3.2 报文的组成部分
3.2.1 报文的语法
3.2.2 起始行
3.2.3 首部
3.2.4 实体的主体部分
3.2.5 版本0.9的报文
3.3 方法
3.3.1 安全方法
3.3.2 GET
3.3.3 HEAD
3.3.4 PUT
3.3.5 POST
3.3.6 TRACE
3.3.7 OPTIONS
3.3.8 DELETE
3.3.9 扩展方法
3.4 状态码
3.4.1～199——信息性状态码
3.4.2～299——成功状态码
3.4.3～399——重定向状态码
3.4.4～499——客户端错误状态码
3.4.5～599——服务器错误状态码
3.5 首部
3.5.1 通用首部
3.5.2 请求首部
3.5.3 响应首部
3.5.4 实体首部
3.6 更多信息
第4章 连接管理
4.1 TCP连接
4.1.1 TCP的可靠数据管道
4.1.2 TCP流是分段的、由IP分组传送
4.1.3 保持TCP连接的正确运行
4.1.4 用TCP套接字编程
4.2 对TCP性能的考虑
4.2.1 HTTP事务的时延
4.2.2 性能聚焦区域
4.2.3 TCP连接的握手时延
4.2.4 延迟确认
4.2.5 TCP慢启动
4.2.6 Nagle算法与TCP_NODELAY
4.2.7 TIME_WAIT累积与端口耗尽
4.3 HTTP连接的处理
4.3.1 常被误解的Connection首部
4.3.2 串行事务处理时延
4.4 并行连接
4.4.1 并行连接可能会提高页面的加载速度
4.4.2 并行连接不一定更快
4.4.3 并行连接可能让人“感觉”更快一些
4.5 持久连接
4.5.1 持久以及并行连接
4.5.2 HTTP/1.0+ keep-alive连接
4.5.3 Keep-Alive操作
4.5.4 Keep-Alive选项
4.5.5 Keep-Alive连接的限制和规则
4.5.6 Keep-Alive和哑代理
4.5.7 插入Proxy-Connection
4.5.8 HTTP/1.1持久连接
4.5.9 持久连接的限制和规则
4.6 管道化连接
4.7 关闭连接的奥秘
4.7.1 “任意”解除连接
4.7.2 Content-Length及截尾操作
4.7.3 连接关闭容限、重试以及幂等性
4.7.4 正常关闭连接
4.8 更多信息
4.8.1 HTTP连接
4.8.2 HTTP性能问题
4.8.3 TCP/IP
第5章 Web服务器
5.1 各种形状和尺寸的Web服务器
5.1.1 Web服务器的实现
5.1.2 通用软件Web服务器
5.1.3 Web服务器设备
5.1.4 嵌入式Web服务器
5.2 zui小的Perl Web服务器
5.3 实际的Web服务器会做些什么
5.4 diyi步——接受客户端连接
5.4.1 处理新连接
5.4.2 客户端主机名识别
5.4.3 通过ident确定客户端用户
5.5 第二步——接收请求报文
5.5.1 报文的内部表示法
5.5.2 连接的输入/输出处理结构
5.6 第三步——处理请求
5.7 第四步——对资源的映射及访问
5.7.1 docroot
5.7.2 目录列表
5.7.3 动态内容资源的映射
5.7.4 服务器端包含项
5.7.5 访问控制
5.8 第五步——构建响应
5.8.1 响应实体
5.8.2 MIME类型
5.8.3 重定向
5.9 第六步——发送响应
5.10 第七步——记录日志
5.11 更多信息
第6章 代理
6.1 Web的中间实体
6.1.1 私有和共享代理
6.1.2 代理与网关的对比
6.2 为什么使用代理
6.3 代理会去往何处
6.3.1 代理服务器的部署
6.3.2 代理的层次结构
6.3.3 代理是如何获取流量的
6.4 客户端的代理设置
6.4.1 客户端的代理配置：手工配置
6.4.2 客户端代理配置：PAC文件
6.4.3 客户端代理配置：WPAD
6.5 与代理请求有关的一些棘手问题
6.5.1 代理URI与服务器URI的不同
6.5.2 与虚拟主机一样的问题
6.5.3 拦截代理会收到部分URI
6.5.4 代理既可以处理代理请求，也可以处理服务器请求
6.5.5 转发过程中对URI的修改
6.5.6 URI的客户端自动扩展和主机名解析
6.5.7 没有代理时URI的解析
6.5.8 有显式代理时URI的解析
6.5.9 有拦截代理时URI的解析
6.6 追踪报文
6.6.1 Via首部
6.6.2 TRACE方法
6.7 代理认证
6.8 代理的互操作性
6.8.1 处理代理不支持的首部和方法
6.8.2 OPTIONS：发现对可选特性的支持
6.8.3 Allow首部
6.9 更多信息
第7章 缓存
7.1 冗余的数据传输
7.2 带宽瓶颈
7.3 瞬间拥塞
7.4 距离时延
7.5 命中和未命中的
7.5.1 再验证
7.5.2 命中率
7.5.3 字节命中率
7.5.4 区分命中和未命中的情况
7.6 缓存的拓扑结构
7.6.1 私有缓存
7.6.2 公有代理缓存
7.6.3 代理缓存的层次结构
7.6.4 网状缓存、内容路由以及对等缓存
7.7 缓存的处理步骤
7.7.1 diyi步——接收
7.7.2 第二步——解析
7.7.3 第三步——查找
7.7.4 第四步——新鲜度检测
7.7.5 第五步——创建响应
7.7.6 第六步——发送
7.7.7 第七步——日志
7.7.8 缓存处理流程图
7.8 保持副本的新鲜
7.8.1 文档过期
7.8.2 过期日期和使用期
7.8.3 服务器再验证
7.8.4 用条件方法进行再验证
7.8.5 If-Modified-Since:Date再验证
7.8.6 If-None-Match：实体标签再验证
7.8.7 强弱验证器
7.8.8 什么时候应该使用实体标签和zui近修改日期
7.9 控制缓存的能力
7.9.1 no-Store与no-Cache响应首部
7.9.2 max-age响应首部
7.9.3 Expires响应首部
7.9.4 must-revalidate响应首部
7.9.5 试探性过期
7.9.6 客户端的新鲜度限制
7.9.7 注意事项
7.10 设置缓存控制
7.10.1 控制Apache的HTTP首部
7.10.2 通过HTTP-EQUIV控制HTML缓存
7.11 详细算法
7.11.1 使用期和新鲜生存期
7.11.2 使用期的计算
7.11.3 完整的使用期计算算法
7.11.4 新鲜生存期计算
7.11.5 完整的服务器——新鲜度算法
7.12 缓存和广告
7.12.1 发布广告者的两难处境
7.12.2 发布者的响应
7.12.3 日志迁移
7.12.4 命中计数和使用限制
7.13 更多信息
第8章 集成点：网关、隧道及中继
8.1 网关
8.2 协议网关
8.2.1 HTTP/*：服务器端Web网关
8.2.2 HTTP/HTTPS：服务器端安quan网 关
8.2.3 HTTPS/HTTP客户端安全加速器网关
8.3 资源网关
8.3.1 CGI
8.3.2 服务器扩展API
8.4 应用程序接口和Web服务
8.5 隧道
8.5.1 用CONNECT建立HTTP隧道
8.5.2 数据隧道、定时及连接管理
8.5.3 SSL隧道
8.5.4 SSL隧道与HTTP/HTTPS网关的对比
8.5.5 隧道认证
8.5.6 隧道的安全性考虑
8.6 中继
8.7 更多信息
第9章 Web机器人
9.1 爬虫及爬行方式
9.1.1 从哪儿开始：根集
9.1.2 链接的提取以及相对链接的标准化
9.1.3 避免环路的出现
9.1.4 循环与复制
9.1.5 面包屑留下的痕迹
9.1.6 别名与机器人环路
9.1.7 规范化URL
9.1.8 文件系统连接环路
9.1.9 动态虚拟Web空间
9.1.10 避免循环和重复
9.2 机器人的HTTP
9.2.1 识别请求首部
9.2.2 虚拟主机
9.2.3 条件请求
9.2.4 对响应的处理
9.2.5 User-Agent导向
9.3 行为不当的机器人
9.4 拒绝机器人访问
9.4.1 拒绝机器人访问标准
9.4.2 Web站点和robots.txt文件
9.4.3 robots.txt文件的格式
9.4.4 其他有关robots.txt的知识
9.4.5 缓存和robots.txt的过期
9.4.6 拒绝机器人访问的Perl代码
9.4.7 HTML的robot-control元标签
9.5 机器人的规范
9.6 搜索引擎
9.6.1 大格局
9.6.2 现代搜索引擎结构
9.6.3 全文索引
9.6.4 发布查询请求
9.6.5 对结果进行排序，并提供查询结果
9.6.6 欺诈
9.7 更多信息
第10章 HTTP-NG
10.1 HTTP发展中存在的问题
10.2 HTTP-NG的活动
10.3 模块化及功能增强
10.4 分布式对象
10.5 diyi层——报文传输
10.6 第二层——远程调用
10.7 第三层——Web应用
10.8 WebMUX
10.9 二进制连接协议
10.10 当前的状态
10.11 更多信息
第11章 客户端识别与cookie机制
11.1 个性化接触
11.2 HTTP首部
11.3 客户端IP地址
11.4 用户登录
11.5 胖URL
11.6 cookie
11.6.1 cookie的类型
11.6.2 cookie是如何工作的
11.6.3 cookie罐：客户端的状态
11.6.4 不同站点使用不同的cookie
11.6.5 cookie成分
11.6.6 cookies版本0(Netscape)
11.6.7 cookies版本1(RFC)
11.6.8 cookie与会话跟踪
11.6.9 cookie与缓存
11.6.10 cookie、安全性和隐私
11.7 更多信息
第12章 基本认证机制
12.1 认证
12.1.1 HTTP的质询/响应认证框架
12.1.2 认证协议与首部
12.1.3 安全域
12.2 基本认证
12.2.1 基本认证实例
12.2.2 Base-64用户名/密码编码
12.2.3 代理认证
12.3 基本认证的安全缺陷
12.4 更多信息
第13章 摘要认证
13.1 摘要认证的改进
13.1.1 用摘要保护密码
13.1.2 单向摘要
13.1.3 用随机数防止重放攻击
13.1.4 摘要认证的握手机制
13.2 摘要的计算
13.2.1 摘要算法的输入数据
13.2.2 算法H(d)和KD(s,d)
13.2.3 与安全性相关的数据(A1)
13.2.4 与报文有关的数据(A2)
13.2.5 摘要算法总述
13.2.6 摘要认证会话
13.2.7 预授权
13.2.8 随机数的选择
13.2.9 对称认证
13.3 增强保护质量
13.3.1 报文完整性保护
13.3.2 摘要认证首部
13.4 应该考虑的实际问题
13.4.1 多重质询
13.4.2 差错处理
13.4.3 保护空间
13.4.4 重写URI
13.4.5 缓存
13.5 安全性考虑
13.5.1 首部篡改
13.5.2 重放攻击
13.5.3 多重认证机制
13.5.4 词典攻击
13.5.5 恶意代理攻击和中间人攻击
13.5.6 选择明文攻击
13.5.7 存储密码
13.6 更多信息
第14章 安全HTTP
14.1 保护HTTP 的安全
14.2 数字加密
14.2.1 密码编制的机制与技巧
14.2.2 密码
14.2.3 密码机
14.2.4 使用了密钥的密码
14.2.5 数字密码
14.3 对称密钥加密技术
14.3.1 密钥长度与枚举攻击
14.3.2 建立共享密钥
14.4 公开密钥加密技术
14.4.1 RSA
14.4.2 混合加密系统和会话密钥
14.5 数字签名
14.6 数字证书
14.6.1 证书的主要内容
14.6.2 X.509 v3证书
14.6.3 用证书对服务器进行认证
14.7 HTTPS——细节介绍
14.7.1 HTTPS概述
14.7.2 HTTPS方案
14.7.3 建立安全传输
14.7.4 SSL握手
14.7.5 服务器证书
14.7.6 站点证书的有效性
14.7.7 虚拟主机与证书
14.8 HTTPS客户端实例
14.8.1 OpenSSL
14.8.2 简单的HTTPS客户端
14.8.3 执行OpenSSL客户端
14.9 通过代理以隧道形式传输安全流量
14.10 更多信息
14.10.1 HTTP安全性
14.10.2 SSL与TLS
14.10.3 公开密钥基础设施
14.10.4 数字密码
第15章 实体和编码
15.1 报文是箱子，实体是货物
15.2 Content-Length: 实体的大小
15.2.1 检测截尾
15.2.2 错误的Content-Length
15.2.3 Content-Length与持久连接
15.2.4 内容编码
15.2.5 确定实体主体长度的规则
15.3 实体摘要
15.4 媒体类型和字符集
15.4.1 文本的字符编码
15.4.2 多部分媒体类型
15.4.3 多部分表格提交
15.4.4 多部分范围响应
15.5 内容编码
15.5.1 内容编码过程
15.5.2 内容编码类型
15.5.3 Accept-Encoding首部
15.6 传输编码和分块编码
15.6.1 可靠传输
15.6.2 Transfer-Encoding首部
15.6.3 分块编码
15.6.4 内容编码与传输编码的结合
15.6.5 传输编码的规则
15.7 随时间变化的实例
15.8 验证码和新鲜度
15.8.1 新鲜度
15.8.2 有条件的请求与验证码
15.9 范围请求
15.10 差异编码
15.11 更多信息
第16章 国际化
16.1 HTTP对国际性内容的支持
16.2 字符集与HTTP
16.2.1 字符集是把字符转换为二进制码的编码
16.2.2 字符集和编码如何工作
16.2.3 字符集不对，字符就不对
16.2.4 标准化的MIME charset值
16.2.5 Content-Type首部和Charset首部以及META标志
16.2.6 Accept-Charset首部
16.3 多语言字符编码入门