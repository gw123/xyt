第1章基础知识
1.1机器语言
1.2汇编语言的产生
1.3汇编语言的组成
1.4存储器
1.5指令和数据
1.6存储单元
1.7CPU对存储器的读写
1.8地址总线
1.9数据总线
1.10控制总线.
1.11内存地址空间（概述）
1.12主板
1.13接口卡
1.14各类存储器芯片
1.15内存地址空间
第2章寄存器
2.1通用寄存器
2.2字在寄存器中的存储
2.3几条汇编指令
2.4物理地址
2.516位结构的CPU
2.68086CPU给出物理地址的方法
2.7“段地址x16 偏移地址=物理地址”的本质含义
2.8段的概念
2.9段寄存器
2.10CS和IP
2.11修改CS、IP的指令
2.12代码段
第3章寄存器（内存访问）
3.1内存中字的存储
3.2DS和[address]
3.3字的传送
3.4mov、add、sub指令
3.5数据段
3.6栈
3.7CPU提供的栈机制.
3.8栈顶超界的问题
3.9push、pop指令
3.10栈段
第4章第一个程序
4.1一个源程序从写出到执行的过程
4.2源程序
4.3编辑源程序
4.4编译
4.5连接
4.6以简化的方式进行编译和连接.
4.71.exe的执行
4.8谁将可执行文件中的程序装载进入内存并使它运行？
4.9程序执行过程的跟踪
第5章[BX]和loop指令
5.1[BX]
5.2Loop指令
5.3在Debug中跟踪用loop指令实现的循环程序
5.4Debug和汇编编译器masm对指令的不同处理
5.5loop和[bx]的联合应用
5.6段前缀
5.7一段安全的空间
5.8段前缀的使用
第6章包含多个段的程序
6.1在代码段中使用数据
6.2在代码段中使用栈
6.3将数据、代码、栈放入不同的段
第7章更灵活的定位内存地址的方法
7.1and和or指令.
7.2关于ASCII码
7.3以字符形式给出的数据
7.4大小写转换的问题
7.5[bx idata].
7.6用[bx idata]的方式进行数组的处理
7.7SI和DI.
7.8Lbx si]和[bx di]
7.9[bx si idata]和[bx di idata]
7.10不同的寻址方式的灵活应用
第8章数据处理的两个基本问题
8.1bx、Sl、di币口bp
8.2机器指令处理的数据在什么地方
8.3汇编语言中数据位置的表达
8.4寻址方式
8.5指令要处理的数据有多长
8.6寻址方式的综合应用
8.7div指令
8.8伪指令dd.
8.9dUp
第9章转移指令的原理
9.1操作符offset
9.2jmp指令
9.3依据位移进行转移的jmp指令.
9.4转移的目的地址在指令中的jmp指令
9.5转移地址在寄存器中的jmp指令.
9.6转移地址在内存中的jmp指令.
9.7jcxz指令
9.8loop指令
9.9根据位移进行转移的意义
9.10编译器对转移位移超界的检测
第10章CALL和RET指令
10.1ret和retf.
10.2call指令
10.3依据位移进行转移的call指令
10.4转移的目的地址在指令中的call指令
10.5转移地址在寄存器中的call指令
10.6转移地址在内存中的call指令.
10.7call和ret的配合使用
10.8mul指令
10.9模块化程序设计
10.10参数和结果传递的问题
10.11批量数据的传递
10.12寄存器冲突的问题
第11章标志寄存器
11.1ZF标志
11.2PF标志
11.3SF标志
11.4CF标志
11.50F标志
第12章内中断
第13章int指令
第14章端口
第15章外中断
第16章直接定址表
第17章使用BIOS进行键盘输入和磁盘读写