第1章 Hello Unity 3D
1.1 Unity 3D 游戏引擎进化史
1.2 Unity 3D 编辑器初印象
1.2.1 Project 视图
1.2.2 Inspector 视图8
1.2.3 Hierarchy 视图
1.2.4 Game 视图
1.2.5 Scene 视图12
1.2.6 绘图模式
1.2.7 渲染模式16
1.2.8 场景视图控制
1.2.9 Effects 菜单和Gizmos 菜单18
1.3 Unity 3D 的组成
1.4 为何需要游戏脚本
1.5 本章总结
第2章 Mono 所搭建的脚本核心基础22
2.1 Mono 是什么22
2.1.1 Mono 的组成22
2.1.2 Mono 运行时
2.2 Mono 如何扮演脚本的角色24
2.2.1 Mono 和脚本
2.2.2 Mono 运行时的嵌入26
2.3 Unity 3D 为何能跨平台？聊聊CIL38
2.3.1 Unity 3D 为何能跨平台
2.3.2 CIL 是什么
2.3.3 Unity 3D 如何使用CIL 跨平台
2.4 脚本的选择，C# 或 JavaScript48
2.4.1 最熟悉的陌生人——UnityScript48
2.4.2 UnityScript 与 JavaScript
2.4.3 C#与UnityScript
2.5 本章总结57
第3章 Unity 3D 脚本语言的类型系统58
3.1 C#的类型系统
3.2 值类型和引用类型
3.3 Unity 3D 脚本语言中的引用类型73
3.4 Unity 3D 游戏脚本中的值类型90
3.4.1 Vector2、Vector3 以及Vector4
3.4.2 其他常见的值类型94
3.5 装箱和拆箱95
3.6 本章总结98
第4章 Unity 3D 中常用的数据结构99
4.1 Array 数组100
4.2 ArrayList 数组101
4.3 List＜T＞数组102
4.4 C#中的链表——LinkedList＜T＞103
4.5 队列（Queue＜T＞）和栈（Stack＜T＞）107
4.6 Hash Table（哈希表）和Dictionary＜K,T＞（字典）112
4.7 本章总结120
第5章 在Unity 3D 中使用泛型121
5.1 为什么需要泛型机制121
5.2 Unity 3D 中常见的泛型
5.3 泛型机制的基础127
5.3.1 泛型类型和类型参数
5.3.2 泛型类型和继承131
5.3.3 泛型接口和泛型委托
5.3.4 泛型方法136
5.4 泛型中的类型约束和类型推断139
5.4.1 泛型中的类型约束139
5.4.2 类型推断144
5.5 本章总结146
第6章 在Unity 3D 中使用委托149
6.1 向Unity 3D 中的SendMessage 和BroadcastMessage 说拜拜150
6.2 认识回调函数机制——委托151
6.3 委托是如何实现的154
6.4 委托是如何调用多个方法的
6.5 用事件（Event）实现消息系统164
6.6 事件是如何工作的
6.7 定义事件的观察者，实现观察者模式
6.8 委托的简化语法
6.8.1 不必构造委托对象177
6.8.2 匿名方法
6.8.3 Lambda 表达式
6.9 本章总结
第7章 Unity 3D 中的定制特性
7.1 初识特性——Attribute
7.1.1 DllImport 特性203
7.1.2 Serializable 特性
7.1.3 定制特性到底是谁
7.2 Unity 3D 中提供的常用定制特性208
7.3 定义自己的定制特性类
7.4 检测定制特性
7.5 亲手拓展Unity 3D 的编辑器
7.6 本章总结227
第8章 Unity 3D 协程背后的迭代器
8.1 初识Unity 3D 中的协程
8.1.1 使用StartCoroutine 方法开启协程
8.1.2 使用StopCoroutine 方法停止一个协程
8.2 使用协程实现延时效果234
8.3 Unity 3D 协程背后的秘密——迭代器
8.3.1 你好，迭代器
8.3.2 原来是状态机
8.3.3. 状态管理
8.4 WWW和协程
8.5 Unity 3D 协程代码实例
8.6 本章总结259
第9章 在Unity 3D 中使用可空型
9.1 如果没有值260
9.2 表示空值的一些方案
9.2.1 使用魔值
9.2.2 使用标志位
9.2.3 借助引用类型来表示值类型的空值
9.3 使用可空值类型
9.4 可空值类型的简化语法
9.5 可空值类型的装箱和拆箱
9.6 本章总结
第10章 从序列化和反序列化看Unity 3D 的存储机制
10.1 初识序列化和反序列化
10.2 控制类型的序列化和反序列化
10.2.1 如何使类型可以序列化
10.2.2 如何选择序列化的字段和控制反序列化的流程
10.2.3 序列化、反序列化中流的上下文介绍及应用
10.3 Unity 3D 中的序列化和反序列化
10.3.1 Unity 3D 的序列化概览
10.3.2 对Unity 3D 游戏脚本进行序列化的注意事项302
10.3.3 如何利用Unity 3D 提供的序列化器对自定义类型进行序列化
10.4 Prefab 和实例化之谜——序列化和反序列化的过程309
10.4.1 认识预制体Prefab
10.4.2 实例化一个游戏对象311
10.4.3 序列化和反序列化之谜314
10.5 本章总结317
第11章 移动平台动态读取外部文件
11.1 假如我想在编辑器里动态读取文件318
11.2 移动平台的资源路径问题
11.3 移动平台读取外部文件的方法323
11.4 使用Resources 类加载资源330
11.5 使用WWW类加载资源332
11.5.1 利用WWW类的构造函数实现资源下载332
11.5.2 利用 WWW.LoadFromCacheOrDownload 方法实现资源下载333
11.5.3 利用WWWForm 类实现POST 请求335
11.6 本章总结335
第12章 在Unity 3D 中使用AssetBundle
12.1 初识AssetBundle
12.2 使用AssetBundle 的工作流程337
12.2.1 开发阶段
12.2.2 运行阶段340
12.3 如何使用本地磁盘中的AssetBundle 文件344
12.4 AssetBundle 文件的平台兼容性345
12.5 AssetBundle 如何识别资源345
12.6 本章总结346
第13章 Unity 3D 优化347
13.1 看看Unity 3D 优化需要从哪里着手
13.2 CPU 方面的优化348
13.2.1 对DrawCall 的优化
13.2.2 对物理组件的优化
13.2.3 处理内存，却让CPU 受伤的GC355
13.2.4 对代码质量的优化356
13.3 对GPU 的优化
13.3.1 减少绘制的数目358
13.3.2 优化显存带宽358
13.4 内存的优化
13.4.1 Unity 3D 的内部内存
13.4.2 Mono 的托管内存
13.5 本章总结
第14章 Unity 3D 的脚本编译
14.1 Unity 3D 脚本编译流程概览365
14.2 JIT 即时编译368
14.2.1 使用编译器将游戏脚本编译为托管模块368
14.2.2 托管模块和程序集
14.2.3 使用JIT 编译执行程序集的代码
14.2.4 使用JIT 即时编译的优势
14.3 AOT 提前编译372
14.3.1 在Unity 3D 中使用AOT 编译372
14.3.2 iOS 平台和Full-AOT 编译
14.3.3 AOT 编译的优势
14.4 谁偷了我的热更新？Mono、JIT 还是iOS
14.4.1 从一个常见的报错说起375
14.4.2 美丽的JIT
14.4.3 模拟JIT 的过程
14.4.4 iOS 平台的自我保护
14.5 Unity 3D 项目的编译与发布
14.5.1 选择游戏场景和目标平台
14.5.2 Unity 3D 发布项目的内部过程384
14.5.3 Unity 3D 部署到Android 平台
14.5.4 Unity 3D 部署到iOS 平台
14.6 本章总结