第1章　Node简介
1.1 Node的诞生历程
1.2 Node的命名与起源
1.2.1 为什么是JavaScript
1.2.2 为什么叫Node
1.3 Node给JavaScript带来的意义
1.4 Node的特点
1.4.1 异步I/O
1.4.2 事件与回调函数
1.4.3 单线程
1.4.4 跨平台
1.5 Node的应用场景
1.5.1 I/O密集型
1.5.2 是否不擅长CPU密集型业务
1.5.3 与遗留系统和平共处
1.5.4 分布式应用
1.6 Node的使用者
1.7 参考资源
第2章　模块机制
2.1 CommonJS规范
2.1.1 CommonJS的出发点
2.1.2 CommonJS的模块规范
2.2 Node的模块实现
2.2.1 优先从缓存加载
2.2.2 路径分析和文件定位
2.2.3 模块编译
2.3 核心模块
2.3.1 JavaScript核心模块的编译过程
2.3.2 C/C++核心模块的编译过程
2.3.3 核心模块的引入流程
2.3.4 编写核心模块
2.4 C/C++扩展模块
2.4.1 前提条件
2.4.2 C/C++扩展模块的编写
2.4.3 C/C++扩展模块的编译
2.4.4 C/C++扩展模块的加载
2.5 模块调用栈
2.6 包与NPM
2.6.1 包结构
2.6.2 包描述文件与NPM
2.6.3 NPM常用功能
2.6.4 局域NPM
2.6.5 NPM潜在问题
2.7 前后端共用模块
2.7.1 模块的侧重点
2.7.2 AMD规范
2.7.3 CMD规范
2.7.4 兼容多种模块规范
2.8 总结
2.9 参考资源
第3章 异步I/O
3.1 为什么要异步I/O
3.1.1 用户体验
3.1.2 资源分配
3.2 异步I/O实现现状
3.2.1 异步I/O与非阻塞I/O
3.2.2 理想的非阻塞异步I/O
3.2.3 现实的异步I/O
3.3 Node的异步I/O
3.3.1 事件循环
3.3.2 观察者
3.3.3 请求对象
3.3.4 执行回调
3.3.5 小结
3.4 非I/O的异步API
3.4.1 定时器
3.4.2 process.nextTick()
3.4.3 setImmediate()
3.5 事件驱动与高性能服务器
3.6 总结
3.7 参考资源
第4章　异步编程
4.1 函数式编程
4.1.1 高阶函数
4.1.2 偏函数用法
4.2 异步编程的优势与难点
4.2.1 优势
4.2.2 难点
4.3 异步编程解决方案
4.3.1 事件发布/订阅模式
4.3.2 Promise/Deferred模式
4.3.3 流程控制库
4.4 异步并发控制
4.4.1 bagpipe的解决方案
4.4.2 async的解决方案
4.5 总结
4.6 参考资源
第5章　内存控制
5.1 V8的垃圾回收机制与内存限制
5.1.1 Node与V8
5.1.2 V8的内存限制
5.1.3 V8的对象分配
5.1.4 V8的垃圾回收机制
5.1.5 查看垃圾回收日志
5.2 高效使用内存
5.2.1 作用域
5.2.2 闭包
5.2.3 小结
5.3 内存指标
5.3.1 查看内存使用情况
5.3.2 堆外内存
5.3.3 小结
5.4 内存泄漏
5.4.1 慎将内存当做缓存
5.4.2 关注队列状态
5.5 内存泄漏排查
5.5.1 node-heapdump
5.5.2 node-memwatch
5.5.3 小结
5.6 大内存应用
5.7 总结
5.8 参考资源
第6章 理解Buffer
6.1 Buffer结构
6.1.1 模块结构
6.1.2 Buffer对象
6.1.3 Buffer内存分配
6.2 Buffer的转换
6.2.1 字符串转Buffer
6.2.2 Buffer转字符串
6.2.3 Buffer不支持的编码类型
6.3 Buffer的拼接
6.3.1 乱码是如何产生的
6.3.2 setEncoding()与string_decoder()
6.3.3 正确拼接Buffer
6.4 Buffer与性能
6.5 总结
6.6 参考资源
第7章　网络编程
7.1 构建TCP服务
7.1.1 TCP
7.1.2 创建TCP服务器端
7.1.3 TCP服务的事件
7.2 构建UDP服务
7.2.1 创建UDP套接字
7.2.2 创建UDP服务器端
7.2.3 创建UDP客户端
7.2.4 UDP套接字事件
7.3 构建HTTP服务
7.3.1 HTTP
7.3.2 http模块
7.3.3 HTTP客户端
7.4 构建WebSocket服务
7.4.1 WebSocket握手
7.4.2 WebSocket数据传输
7.4.3 小结
7.5 网络服务与安全
7.5.1 TLS/SSL
7.5.2 TLS服务
7.5.3 HTTPS服务
7.6 总结
7.7 参考资源
第8章 构建Web应用
8.1 基础功能
8.1.1 请求方法
8.1.2 路径解析
8.1.3 查询字符串
8.1.4 Cookie
8.1.5 Session
8.1.6 缓存
8.1.7 Basic认证
8.2 数据上传
8.2.1 表单数据
8.2.2 其他格式
8.2.3 附件上传
8.2.4 数据上传与安全
8.3 路由解析
8.3.1 文件路径型
8.3.2 MVC
8.3.3 RESTful
8.4 中间件
8.4.1 异常处理
8.4.2 中间件与性能
8.4.3 小结
8.5 页面渲染
8.5.1 内容响应
8.5.2 视图渲染
8.5.3 模板
8.5.4 Bigpipe
8.6 总结
8.7 参考资源
第9章　玩转进程
9.1 服务模型的变迁
9.1.1 石器时代：同步
9.1.2 青铜时代：复制进程
9.1.3 白银时代：多线程
9.1.4 黄金时代：事件驱动
9.2 多进程架构
9.2.1 创建子进程
9.2.2 进程间通信
9.2.3 句柄传递
9.2.4 小结
9.3 集群稳定之路
9.3.1 进程事件
9.3.2 自动重启
9.3.3 负载均衡
9.3.4 状态共享
9.4 Cluster模块
9.4.1 Cluster工作原理
9.4.2 Cluster事件
9.5 总结
9.6 参考资源
第10章 测试
10.1 单元测试
10.1.1 单元测试的意义
10.1.2 单元测试介绍
10.1.3 工程化与自动化
10.1.4 小结
10.2  性能测试
10.2.1 基准测试
10.2.2 压力测试
10.2.3 基准测试驱动开发
10.2.4 测试数据与业务数据的转换
10.3 总结
10.4 参考资源
第11章　产品化
11.1 项目工程化
11.1.1 目录结构
11.1.2 构建工具
11.1.3 编码规范
11.1.4 代码审查
11.2 部署流程
11.2.1 部署环境
11.2.2 部署操作
11.3 性能
11.3.1 动静分离
11.3.2 启用缓存
11.3.3 多进程架构
11.3.4 读写分离
11.4 日志
11.4.1 访问日志
11.4.2 异常日志
11.4.3 日志与数据库
11.4.4 分割日志
11.4.5 小结
11.5 监控报警
11.5.1 监控
11.5.2 报警的实现
11.5.3 监控系统的稳定性
11.6 稳定性
11.7 异构共存
11.8 总结
11.9 参考资源
附录A 安装Node
附录B 调试Node
附录C Node编码规范
附录D 搭建局域NPM仓库


A.1 Windows系统下的Node安装
A.2 Mac系统下Node的安装
A.3 Linux系统下Node的安装
A.4 总结
A.5 参考资源

B.1 Debugger
B.2 Node Inspector
B.2.1 安装Node Inspector
B.2.2 错误堆栈
B.3 总结

C.1 根源
C.2 编码规范
C.2.1 空格与格式
C.2.2 命名规范
C.2.3 比较操作
C.2.4 字面量
C.2.5 作用域
C.2.6 数组与对象
C.2.7 异步
C.2.8 类与模块
C.2.9 注解规范
C.3   最佳实践
C.3.1 冲突的解决原则
C.3.2 给编辑器设置检测工具
C.3.3 版本控制中的hook
C.3.4 持续集成
C.4 总结
C.5 参考资源

D.1 NPM仓库的安装
D.1.1 安装Erlang和CouchDB
D.1.2 搭建NPM仓库
D.2   高阶应用
D.2.1 镜像仓库
D.2.2 私有模块应用
D.2.3 纯私有仓库
D.3 总结
D.4 参考资源