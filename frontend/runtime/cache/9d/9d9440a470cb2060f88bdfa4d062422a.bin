a:2:{i:0;a:10:{i:0;a:20:{s:2:"id";s:3:"242";s:2:"pv";s:2:"66";s:10:"collectnum";s:1:"0";s:5:"title";s:67:"selenium  匹配元素出现.ElementNotInteractableException 异常";s:6:"userid";s:1:"1";s:8:"promoted";s:1:"1";s:10:"categoryid";s:1:"0";s:4:"desc";s:0:"";s:4:"body";s:3144:"<p>&nbsp;今天学习使用&nbsp; selenium 去模拟点击百度的登陆按钮 .&nbsp; 原本以为很简单 对照书上一通抄 结果先是遇到了一堆问题.在这里我就挑2个比较典型的问题说明一下解决方法 .</p><p>&nbsp; 问题1:&nbsp; 在windos 下使用utf-8编码的文件,在windos 下的cmd 终端中输出时中文乱码&nbsp; ,更可气的是 在程序执行过程中我在获取一组 a标签后我遍历输出他们的text&nbsp; 居然直接给我报错 . <br/><img src="/files/image/20170622/1498063081768408.png" title="1498063081768408.png" alt="图片.png" width="689" height="134"/></p><p><br/></p><p>&nbsp;网上百度了一些解决方法 ,有的说是修改cmd 终端的代码页&nbsp; ,但是还是有问题&nbsp; . 还有一些解决方案就是 在输出时编码一下&nbsp; , 看到这个时候 我内心也是很绝望的 ,我就是想输出一个内容有必要搞这么复杂吗.&nbsp;&nbsp; 最后我摸索到一个最好的解决方案早一个可以显示utf-8的终端不久可以了吗.&nbsp; 后来发现pyCharm这个神器,(Ps:如果你用的也是这个编辑器的话,但我什么都没有说过 , 毕竟我是业余python&nbsp; 平时都是用的 记事本的).</p><p><br/></p><p>问题2:&nbsp;&nbsp; 我要让seleium 去模拟点击一个注册按钮 , 但是我照书上来的&nbsp; 可是结果就是行不通.&nbsp;&nbsp; 废话不多直接上截图.</p><p><img src="/files/image/20170622/1498064296402647.png" title="1498064296402647.png" alt="图片.png"/><br/></p><p>这个代码 既然是作者写的,想必当时他也是测试过的 ,但是到我这里 突然就程序崩溃了. 抛了一个ElementNotInteractableException 异常, 起初我要没有去关心这个异常 ,直觉告诉我应该是匹配的方式有问题, 后来我换了用css 的那么属性去匹配,结果也是没有匹配上 . 后来无意间在浏览器上输出了一下这个元素<br/></p><p><img src="/files/image/20170622/1498063819859271.png" title="1498063819859271.png" alt="图片.png" width="834" height="78"/></p><p>注意重点来了 匹配到了两个元素 , 我测试了一下我要匹配的登陆按钮正好是匹配到的第二个元素 . 突然恍然大悟 原来之前我操作的都是上图中的第一个元素而这个原始是隐藏掉的 ,在仔细百度一下ElementNotInteractableException 这个异常 原来这个异常的意识是原始不可操作的意思 . 之前我的主观意识都是没有匹配到这个元素原来是我想错了. 想到这里我换了一个匹配方式.&nbsp; 后来我得出一个结论就是百度后面给这个页面多加一个隐藏掉的 a 标签 内容和我要匹配的一毛一样(想到这里我有陷入了沉思... 好像说三个字***).<br/></p><pre style="background-color:#ffffff;color:#000000;font-family:&#39;Courier New&#39;;font-size:14pt;"><p>driver.find_elements_by_link_text(u&#39;登录&#39;)[1].click()<br/><br/><span style="font-size: 16px;">好了终于弹出了注册款. <br/><br/>本篇文章就说到这里 , 大家有什么想法欢迎交流 . <br/></span><br/></p></pre><p><br/></p><p><br/></p><p><br/></p>";s:7:"picture";s:0:"";s:11:"createdtime";s:10:"1498064261";s:8:"category";s:9:"1000,1116";s:7:"chapter";s:14:"4800,4807,4809";s:8:"nickname";s:5:"gw123";s:6:"avatar";s:26:"/images/default/avatar.png";s:8:"desc_len";s:1:"0";s:8:"body_len";s:3:"861";s:10:"status_len";s:1:"1";s:11:"createdTime";s:10:"1498064261";s:6:"userId";s:1:"1";}i:1;a:20:{s:2:"id";s:3:"239";s:2:"pv";s:2:"28";s:10:"collectnum";s:1:"0";s:5:"title";s:52:" Selenuim+Python之元素定位总结及实例说明";s:6:"userid";s:1:"1";s:8:"promoted";s:1:"1";s:10:"categoryid";s:1:"0";s:4:"desc";s:0:"";s:4:"body";s:18660:"<p>&nbsp;转载自 &nbsp; 博客园 &nbsp;<a href="http://home.cnblogs.com/u/yufeihlf/">啄木鸟儿</a></p><p>&nbsp;&nbsp;&nbsp;&nbsp;网页自动化最基本的要求就是要定位到各个元素，然后才能对该元素进行各种操作（输入，点击，清除，提交等），所以笔者今天来总结下Selenuim+Python最基本的几种定位方式及实例说明，希望能帮助到大家。</p><p>&nbsp; &nbsp; 另外：学习元素定位方法前，建议先前往<a href="http://www.w3school.com.cn/html/index.asp" target="_blank">http://www.w3school.com.cn/html/index.asp</a> &nbsp;学习html前端基础知识，这个更加有利于定位。</p><p>&nbsp;</p><p><a></a><strong>目录</strong></p><p>1.通过id定位元素<br/>2.通过class_name定位元素<br/>3.通过tag_name定位元素<br/>4.通过name定位元素<br/>5.通过link文字精确定位元素<br/>6.通过link文字模糊定位元素<br/>7.通过CSS定位元素<br/>8.通过XPath定位元素<br/>9.通过By定位元素<a href="http://www.cnblogs.com/yufeihlf/p/5717291.html#test8"><br/></a>10.具体实例说明</p><p>&nbsp;</p><p><strong>以百度搜索输入框为例，具体说明各个定位方式的用法：</strong></p><p>（通过chrome浏览器查看元素或者搜狐浏览器的firebug查看，即可看到html源码）</p><p>注意点：第三行的元素是灰色的，该元素是不可定位到的，下方会说明。</p><p><span class="cnblogs_code_copy"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"/></span></p><pre>&nbsp;&lt;span&nbsp;class=&quot;bg&nbsp;s_ipt_wr&nbsp;quickdelete-wrap&quot;&gt;&nbsp;
&nbsp;&nbsp;&nbsp;&lt;span&nbsp;class=&quot;soutu-btn&quot;&gt;&lt;/span&gt;
&nbsp;&nbsp;&nbsp;&lt;input&nbsp;id=&quot;kw&quot;&nbsp;class=&quot;s_ipt&quot;&nbsp;autocomplete=&quot;off&quot;&nbsp;maxlength=&quot;255&quot;&nbsp;value=&quot;&quot;&nbsp;name=&quot;wd&quot;&gt;
&nbsp;&nbsp;&nbsp;&lt;a&nbsp;id=&quot;quickdelete&quot;&nbsp;class=&quot;quickdelete&quot;&nbsp;href=&quot;javascript:;&quot;&nbsp;title=&quot;清空&quot;&nbsp;style=&quot;top:&nbsp;0px;&nbsp;right:&nbsp;0px;&nbsp;display:&nbsp;none;&quot;&gt;&lt;/a&gt;
&nbsp;&nbsp;&nbsp;&lt;/span&gt;
&nbsp;&nbsp;&nbsp;&lt;span&nbsp;class=&quot;bg&nbsp;s_btn_wr&quot;&gt;&nbsp;
&nbsp;&nbsp;&nbsp;&lt;input&nbsp;id=&quot;su&quot;&nbsp;class=&quot;bg&nbsp;s_btn&quot;&nbsp;type=&quot;submit&quot;&nbsp;value=&quot;百度一下&quot;&gt;
&nbsp;&nbsp;&lt;/span&gt;</pre><p><span class="cnblogs_code_copy"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"/></span></p><p><img src="http://images2015.cnblogs.com/blog/878193/201607/878193-20160729111850278-1804474795.jpg" alt=""/></p><p><a></a><strong>1.通过id定位元素</strong></p><p>如果id不是动态的，一个页面的id是唯一的。最简单的定位方式。</p><p>使用：find_element_by_id(&quot;id_vaule&quot;)</p><p>实例：find_element_by_id(&quot;<span style="color: #ff0000;">kw</span>&quot;)</p><p>注意点：有些id值是动态变化的，则不能使用该方法定位。如下：id就是动态的，每次进入页面，该id都会改变。</p><pre>&lt;label&nbsp;style=&quot;display:&nbsp;block;&quot;&nbsp;id=&quot;auto-id-1469758879170&quot;&nbsp;class=&quot;u-label&nbsp;f-dn&quot;&gt;邮箱帐号或手机号&lt;/label&gt;</pre><p>&nbsp;</p><p><a></a><strong>2.通过class_name定位元素</strong></p><p>classname有可能重复哦。&nbsp;</p><p>使用：find_element_by_class_name(&quot;class_name_vaule&quot;)</p><p>实例：find_element_by_class_name(&quot;<span style="color: #ff0000;">s_ipt</span>&quot;)</p><p>&nbsp;</p><p><a></a><strong>3.通过tag_name定位元素</strong></p><p>标签名字最容易重复，不过，当定位一组数据时，可使用。</p><p>使用：find_element_by_tag_name(&quot;tag_name_vaule&quot;)</p><p>实例：find_element_by_tag_name(&quot;<span style="color: #ff0000;">input</span>&quot;)</p><p>&nbsp;</p><p>注意点：当定位一组元素时：可勾选一组复选框。如下：</p><p>find_element_by_tag_name(&quot;input&quot;)</p><p><img src="http://images2015.cnblogs.com/blog/878193/201607/878193-20160729104543559-1828915974.jpg" alt="" width="240" height="156"/></p><p><span class="cnblogs_code_copy"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"/></span></p><pre>&lt;body&gt;&lt;h3&gt;checkbox&lt;/h3&gt;
&nbsp;&lt;div&nbsp;&nbsp;class=&quot;well&quot;&gt;
&nbsp;&nbsp;&lt;form&nbsp;class=&quot;form-horizontal&quot;&gt;
&nbsp;&nbsp;&lt;div&nbsp;class=&quot;control-group&quot;&gt;&lt;label&nbsp;class=&quot;control-label&quot;&nbsp;for=&quot;c1&quot;&gt;checkbox1&lt;/label&gt;
&nbsp;&nbsp;&lt;div&nbsp;class=&quot;controls&quot;&gt;&lt;input&nbsp;&nbsp;type=&quot;checkbox&quot;&nbsp;id=&quot;c1&quot;/&gt;&lt;/div&gt;
&nbsp;&nbsp;&lt;/div&gt;
&nbsp;&nbsp;&lt;div&nbsp;class=&quot;control-group&quot;&gt;&lt;label&nbsp;class=&quot;control-label&quot;for=&quot;c2&quot;&gt;checkbox2&lt;/label&gt;
&nbsp;&nbsp;&lt;div&nbsp;class=&quot;controls&quot;&gt;&lt;input&nbsp;&nbsp;type=&quot;checkbox&quot;id=&quot;c2&quot;/&gt;&lt;/div&gt;
&nbsp;&nbsp;&lt;/div&gt;
&nbsp;&nbsp;&lt;div&nbsp;class=&quot;control-group&quot;&gt;&lt;label&nbsp;class=&quot;control-label&quot;for=&quot;c3&quot;&gt;checkbox3&lt;/label&gt;
&nbsp;&nbsp;&lt;div&nbsp;class=&quot;controls&quot;&gt;&lt;input&nbsp;&nbsp;type=&quot;checkbox&quot;id=&quot;c3&quot;/&gt;&lt;/div&gt;
&nbsp;&nbsp;&lt;/div&gt;
&nbsp;&nbsp;&lt;/form&gt;
&nbsp;&lt;/div&gt;
&lt;/body&gt;</pre><p><span class="cnblogs_code_copy"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"/></span></p><p>&nbsp;</p><p><a></a><strong>4.通过name定位元素</strong></p><p>name有可能会重复哦。&nbsp;</p><p>使用：find_element_by_name(&quot;name_vaule&quot;)</p><p>实例：find_element_by_name(&quot;<span style="color: #ff0000;">wd</span>&quot;)</p><p>&nbsp;</p><p><a></a><strong>5.通过link文字精确定位元素</strong></p><pre>&lt;a&nbsp;onclick=&quot;return&nbsp;false;&quot;&nbsp;class=&quot;lb&quot;&nbsp;name=&quot;tj_login&quot;&nbsp;href=&quot;https://passport.baidu.com/v2/?login&amp;amp;tpl=mn&amp;amp;u=http%3A%2F%2Fwww.baidu.com%2F&quot;&gt;登录&lt;/a&gt;</pre><p>使用：find_element_by_link_text(&quot;text_vaule&quot;)</p><p>实例：find_element_by_link_text(&quot;<span style="color: #ff0000;">登录</span>&quot;)</p><p>&nbsp;</p><p><a></a><strong>6.通过link文字模糊定位元素</strong></p><p>使用：find_element_by_partial_link_text(&quot;部分text_vaule&quot;)</p><p>实例：find_element_by_partial_link_text(&quot;<span style="color: #ff0000;">登</span>&quot;)</p><p>&nbsp;</p><p><a></a><strong>7.通过CSS定位元素</strong></p><p>可查看我的另外一篇博文：<a class="postTitle2" href="http://www.cnblogs.com/yufeihlf/p/5807624.html" target="_blank">w3school之CSS学习笔记</a>&nbsp;学习css知识，更加有助于定位。</p><p>CSS（Cascading Style Sheets）是一种语言，它用来描述HTML和XML文档的表现。CSS可以较为灵活的选择控件的任意属性，一般情况下会比XPath快。且语法也比较简洁。</p><p>不过CSS对于初学者而言比较复杂。</p><p><img src="http://images2015.cnblogs.com/blog/878193/201607/878193-20160729111850278-1804474795.jpg" alt=""/></p><p>使用：find_element_by_css_selector(&quot;CSS&quot;)</p><p>实例：</p><p>7.1<a></a>通过id属性定位元素</p><p>#号表示通过id属性来定位元素</p><p>find_element_by_css_selector(&quot;<span style="color: #ff0000;">#</span>kw&quot;)</p><p>7.2通过class属性定位元素</p><p>.号表示通过class属性来定位元素</p><p>find_element_by_css_selector(&quot;<span style="color: #ff0000;">.</span>s_ipt&quot;)</p><p>7.3通过标签名定位元素</p><p>find_element_by_css_selector(&quot;input&quot;)</p><p><span style="color: #ff0000;">7.4</span><span style="color: #ff0000;">通过属性定位元素（挺常用的）</span></p><p>find_element_by_css_selector(&quot;<span style="color: #ff0000;">[</span>name=&#39;wd&#39;<span style="color: #ff0000;">]</span>&quot;)</p><p>find_element_by_css_selector(&quot;[maxlength=&#39;255&#39;]&quot;)</p><p>属性值包含某个值</p><p>属性值包含wd：适用于由空格分隔的属性值。</p><p>find_element_by_css_selector(&quot;[name<span style="color: #ff0000;">~</span>=&#39;wd&#39;]&quot;)</p><p>7.5父子定位元素</p><p>查找有父亲元素的标签名为span，它的所有标签名叫input的子元素</p><p>find_element_by_css_selector(&quot;span<span style="color: #ff0000;">&gt;</span>input&quot;)&nbsp;</p><p>7.6组合定位元素</p><p>标签名#id属性值：指的是该input标签下id属性为kw的元素</p><p>find_element_by_css_selector(&quot;input#kw&quot;)</p><p>标签名.class属性值：指的是该input标签下class属性为s_ipt的元素</p><p>find_element_by_css_selector(&quot;input.s_ipt&quot;)</p><p>标签名[属性=’属性值‘]：指的是该input标签下name属性为wd的元素</p><p>find_element_by_css_selector(&quot;input[name=&#39;wd&#39;]&quot;)</p><p>父元素标签名&gt;标签名.class属性值：指的是span下的input标签下class属性为s_ipt的元素</p><p>find_element_by_css_selector(&quot;span&gt;input.s_ipt&quot;)</p><p>&nbsp;</p><p><span style="color: #ff0000;">多个属性组合定位元素（挺常用的）</span></p><p>指的是input标签下id属性为kw且name属性为wd的元素</p><p>find_element_by_css_selector(&quot;input.s_ipt[name=&#39;wd&#39;]&quot;)</p><p>指的是input标签下name属性为wd<span style="color: #ff0000;">且</span>maxlength为255的元素</p><p>find_element_by_css_selector(&quot;input[name=&#39;wd&#39;][maxlength=&#39;255&#39;]&quot;)</p><p>&nbsp;</p><p>比较复杂的CSS定位可查看</p><p>http://www.360doc.com/content/13/1105/10/11675837_326750173.shtml</p><p>http://www.360doc.com/content/13/1105/10/11675837_326750240.shtml</p><p>&nbsp;</p><p>比较懒惰的方法：</p><p>使用搜狐浏览器的firebug工具，复制CSS路径，不过这种方式对层级要求高，到时候自己再修改下。</p><p>&nbsp;</p><p><a></a><strong>8.通过XPath定位元素</strong></p><p>XPath是一种XML文档中定位元素的语言。该定位方式也是比较常用的定位方式。</p><p><img src="http://images2015.cnblogs.com/blog/878193/201607/878193-20160729111850278-1804474795.jpg" alt=""/></p><p>使用：find_element_by_xpath(&quot;XPath&quot;)</p><p>实例：</p><p>8.1通过属性定位元素</p><p>find_element_by_xpath(&quot;<span style="color: #ff0000;">//</span>标签名<span style="color: #ff0000;">[@</span>属性=&#39;属性值&#39;<span style="color: #ff0000;">]</span>&quot;)</p><p>id属性：</p><p><span style="line-height: 1.5;">find_element_by_xpath(&quot;//input[@id=&#39;kw&#39;]&quot;)</span></p><p>class属性：</p><p>find_element_by_xpath(&quot;//input[@class=&#39;s_ipt&#39;]&quot;)</p><p>name属性：</p><p>find_element_by_xpath(&quot;//input[@name=&#39;wd&#39;]&quot;)</p><p>maxlength属性：</p><p>find_element_by_xpath(&quot;//input[@maxlength=&#39;255&#39;]&quot;)</p><p>8.2通过标签名定位元素</p><p>指所有input标签元素</p><p>find_element_by_xpath(&quot;//input&quot;)</p><p>8.3父子定位元素</p><p>查找有父亲元素的标签名为span，它的所有标签名叫input的子元素</p><p>find_element_by_xpath(&quot;//span/input&quot;)&nbsp;</p><p><span style="color: #ff0000;">8.4根据元素内容定位元素（非常实用）</span></p><p>find_element_by_xpath(&quot;//p[<span style="color: #ff0000;">contains</span>(text(),&#39;京公网&#39;)]&quot;)&nbsp;</p><pre>&lt;p&nbsp;id=&quot;jgwab&quot;&gt;
&lt;i&nbsp;class=&quot;c-icon-jgwablogo&quot;&gt;&lt;/i&gt;
京公网安备11000002000001号
&lt;/p&gt;</pre><p>注：contains的另一种用法</p><p>//input[contains(<span style="color: #ff0000;">@</span>class,&#39;s&#39;)]</p><p>说明class属性包含s的元素。</p><p>8.5组合定位元素</p><p>//父元素标签名/标签名的属性值：指的是span下的input标签下class属性为s_ipt的元素</p><p>find_element_by_xpath(&quot;//span/input[@class=&#39;s_ipt&#39;]&quot;)</p><p><span style="color: #ff0000;">多个属性组合定位（挺常用的）</span></p><p>指的是input标签下id属性为kw且name属性为wd的元素</p><p>find_element_by_xpath(&quot;//input[@class=&#39;s_ipt&#39; <span style="color: #ff0000;">and</span> @name=&#39;wd&#39;]&quot;)</p><p>指的是p标签下内容包含“京公网”且id属性为jgwab的元素</p><p>find_element_by_xpath(&quot;//p[contains(text(),&#39;京公网&#39;) and @id=&#39;jgwab&#39;]&quot;)&nbsp;<span style="line-height: 1.5;">&nbsp;</span></p><p>&nbsp;</p><p>比较懒惰的方法：</p><p>使用搜狐浏览器的firebug工具，复制XPath路径，不过这种方式对层级要求高，到时候自己再修改下。</p><p>&nbsp;</p><p><a></a><strong>9.通过By定位元素</strong></p><p>使用：find_element(定位的类型，具体定位方式)</p><p>定位的类型包括By.ID,By.NAME,By.CLASS_NAME,By.TAG_NAME,By.LINK_TEXT,By.PARTIAL_LINK_TEXT,By.XPATH,By.CSS_SELECTOR</p><p>具体定位方式参考上方1-8的说明。</p><p>实例：find_element(By.ID,&#39;kw&#39;)</p><p>注意：使用By定位方式，需先导入By类。</p><pre>from&nbsp;selenium.webdriver.common.by&nbsp;import&nbsp;By</pre><p>&nbsp;</p><p><a></a><strong>10.具体实例说明</strong></p><p>下方例子是登陆126邮件，然后发送邮件。</p><p><span class="cnblogs_code_copy"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"/></span></p><pre>&nbsp;1&nbsp;#&nbsp;coding=utf-8&nbsp;2&nbsp;&#39;&#39;&#39;&nbsp;3&nbsp;Created&nbsp;on&nbsp;2016-7-27&nbsp;4&nbsp;@author:&nbsp;Jennifer&nbsp;5&nbsp;Project:发送邮件&nbsp;6&nbsp;&#39;&#39;&#39;&nbsp;7&nbsp;from&nbsp;selenium&nbsp;import&nbsp;webdriver&nbsp;8&nbsp;import&nbsp;time&nbsp;9&nbsp;10&nbsp;from&nbsp;test_5_2_public&nbsp;import&nbsp;Login&nbsp;&nbsp;#由于公共模块文件命名为test_5_2_public11&nbsp;driver=webdriver.Firefox()12&nbsp;driver.implicitly_wait(30)13&nbsp;driver.get(r&#39;http://www.126.com/&#39;)&nbsp;&nbsp;#字符串加r，防止转义。14&nbsp;time.sleep(3)15&nbsp;driver.switch_to.frame(&#39;x-URS-iframe&#39;)16&nbsp;#调用登录模块17&nbsp;Login().user_login(driver)18&nbsp;time.sleep(10)19&nbsp;#发送邮件20&nbsp;#点击发件箱21&nbsp;#_mail_component_61_61是动态id，所以不能用于定位22&nbsp;#driver.find_element_by_css_selector(&#39;#_mail_component_61_61&gt;span.oz0&#39;).click()23&nbsp;#不能加u&quot;//span[contains(text(),u&#39;写&nbsp;信&#39;)]&quot;，否则定位不到。24&nbsp;#以下定位是查找span标签有个文本（text）包含（contains）&#39;写&nbsp;信&#39;&nbsp;的元素，该定位方法重要25&nbsp;driver.find_element_by_xpath(&quot;//span[contains(text(),&#39;写&nbsp;信&#39;)]&quot;).click()26&nbsp;#填写收件人27&nbsp;#driver.find_element_by_class_name(&#39;nui-editableAddr-ipt&#39;).send_keys(r&#39;xxx@doov.com.cn&#39;)28&nbsp;driver.find_element_by_class_name(&#39;nui-editableAddr-ipt&#39;).send_keys(r&#39;xxx@163.com&#39;)29&nbsp;#填写主题30&nbsp;#通过and连接更多的属性来唯一地标志一个元素31&nbsp;driver.find_element_by_xpath(&quot;//input[@class=&#39;nui-ipt-input&#39;&nbsp;and&nbsp;@maxlength=&#39;256&#39;]&quot;).send_keys(u&#39;自动化测试&#39;)32&nbsp;#填写正文33&nbsp;#通过switch_to_frame()将当前定位切换到frame/iframe表单的内嵌页面中34&nbsp;driver.switch_to_frame(driver.find_element_by_class_name(&#39;APP-editor-iframe&#39;))35&nbsp;#在内嵌页面中定位邮件内容位置36&nbsp;emailcontext=driver.find_element_by_class_name(&#39;nui-scroll&#39;)37&nbsp;#填写邮件内容38&nbsp;emailcontext.send_keys(u&#39;这是第一封自动化测试邮件&#39;)39&nbsp;#通过switch_to().default_content()跳回最外层的页面40&nbsp;#注：不要写成switch_to().default_content(),否则报AttributeError:&nbsp;SwitchTo&nbsp;instance&nbsp;has&nbsp;no&nbsp;__call__&nbsp;method41&nbsp;driver.switch_to.default_content()42&nbsp;#driver.switch_to.parent_frame()43&nbsp;#点击发送44&nbsp;time.sleep(3)45&nbsp;#有可能存在元素不可见（查看元素是灰色的），会报ElementNotVisibleException错误46&nbsp;#包含发送二字的元素很多，所以还得再加上其他限制47&nbsp;#sendemails=driver.find_element_by_xpath(&quot;//span[contains(text(),&#39;发送&#39;)]&quot;)48&nbsp;sendemails=driver.find_element_by_xpath(&quot;//span[contains(text(),&#39;发送&#39;)&nbsp;and&nbsp;@class=&#39;nui-btn-text&#39;]&quot;)49&nbsp;time.sleep(3)50&nbsp;51&nbsp;#校验邮件是否发送成功52&nbsp;try:53&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;assert&nbsp;&#39;发送成功&#39;&nbsp;in&nbsp;driver.page_source54&nbsp;except&nbsp;AssertionError:55&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print&nbsp;&#39;邮件发送成功&#39;56&nbsp;else:57&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print&nbsp;&#39;邮件发送失败&#39;58&nbsp;59&nbsp;#调用退出模块&nbsp;&nbsp;&nbsp;&nbsp;60&nbsp;Login().user_logout(driver)</pre><p><span class="cnblogs_code_copy"><img src="http://common.cnblogs.com/images/copycode.gif" alt="复制代码"/></span></p><p><strong>元素定位说明：</strong><br/>1.代码22行，定位不到是因为id是动态的，所以需采取其他方式定位元素。<span style="font-family: verdana, Arial, Helvetica, sans-serif; font-size: 14px; line-height: 1.5;"><br/></span></p><p>2.代码25行，是根据元素内容来定位的，具体用法详看8.4.</p><p>3.代码28行，是根据class名来定位元素的，由于该值在该页面上是唯一的，所以可以用它来定位。</p><p>4.代码31行，是使用逻辑运算符and连接更多的属性从而唯一的标志一个元素，具体用法详看8.5.</p><p>5.代码34行，由于使用内嵌的iframe框架，所以需要先使用switch_to_frame()移到该表单上，才能定位该表单上的元素，非常重要，否则无论怎么定位都会报“NoSuchElementException”，找不到该元素。</p><p>6.代码41行，跳出iframe框架，当框架内的动作操作完毕后，需要使用switch_to.default_content跳出iframe框架,非常重要。</p><p>7.代码47行，由于内容包括“发送”的元素中包含不可见元素（html查看元素可以看到此行是灰色的），这样有可能定位到不可见元素，会报“ElementNotVisibleException”。</p><p>8.代码48行，是使用逻辑运算符and连接更多的属性从而唯一的标志一个元素，具体用法详看8.5.这样可以排除掉那个不可见元素。</p>";s:7:"picture";s:0:"";s:11:"createdtime";s:10:"1497876567";s:8:"category";s:9:"1000,1116";s:7:"chapter";s:14:"4800,4807,4809";s:8:"nickname";s:5:"gw123";s:6:"avatar";s:26:"/images/default/avatar.png";s:8:"desc_len";s:1:"0";s:8:"body_len";s:4:"4405";s:10:"status_len";s:1:"1";s:11:"createdTime";s:10:"1497876567";s:6:"userId";s:1:"1";}i:2;a:20:{s:2:"id";s:3:"240";s:2:"pv";s:2:"23";s:10:"collectnum";s:1:"0";s:5:"title";s:21:"PHP常用的服务器";s:6:"userid";s:1:"1";s:8:"promoted";s:2:"10";s:10:"categoryid";s:1:"0";s:4:"desc";s:0:"";s:4:"body";s:6281:"<h5>推荐几款一键快速搭建PHP本地运行环境的好工具(含php7.0及apache，nigix，mysql)首推phpstudy2016和wampServer3.0.6&nbsp; 理由支持php7.0</h5><p>目前热门php框架如：laravel5.2要求php版本5.6以上，thinkphp及yii也对php版本有要求</p><h2><span style="font-size: 12px; font-family: 宋体;">一键搭建PHP运行环境工具</span></h2><h3><span style="font-size: 12px; font-family: 宋体;">1.APMServ&nbsp;http://apmserv.s135.com/</span></h3><p><span style="font-size: 12px; font-family: 宋体;">优点：功能强大，一键启动。&nbsp;</span><span style="font-size: 12px; font-family: 宋体;">缺点：不支持php5.0</span></p><p><span style="font-size: 12px;"><img src="http://images2015.cnblogs.com/blog/966404/201609/966404-20160905094003660-1379010499.png" alt="" width="403" height="298"/></span></p><p><span style="font-size: 12px;">&nbsp;</span></p><p><span style="font-size: 12px;">&nbsp;<strong>2. phpstudy &nbsp; &nbsp; &nbsp;&nbsp;<a href="http://www.phpstudy.net/phpstudy/phpStudy.zip" target="_blank">http://www.phpstudy.net/phpstudy/phpStudy.zip</a></strong></span></p><p><span style="font-size: 12px;"><strong>特点支持php7.0</strong></span></p><p><span style="font-size: 12px;"><img src="http://images2015.cnblogs.com/blog/966404/201609/966404-20160905093639176-50382914.png" alt="" width="306" height="258"/></span></p><p><span style="font-size: 12px;">&nbsp;</span></p><h3><span style="font-size: 12px;">3.WampServer &nbsp; &nbsp;http://www.wampserver.com/</span></h3><p><span style="font-size: 12px;">支持php7.0</span></p><p><span style="font-size: 12px;">Windows下的Apache+PHP+MySQL的服务器软件。PHP 扩展、Apache模块，</span><span style="font-size: 12px;">但是程序支持中文。它能切换在线和离线状态，选项中的文语言项中也有简体中文可选.</span></p><p><span style="font-size: 12px;"><img src="http://images2015.cnblogs.com/blog/966404/201609/966404-20160905094432707-1303584092.jpg" alt=""/></span></p><p><span style="font-size: 12px; line-height: 1.5;">&nbsp;</span></p><h3><span style="font-size: 12px;">4.Xampp</span></h3><p><span style="font-size: 12px;">&nbsp;http://www.apachefriends.org/zh_cn/index.html</span></p><p><span style="font-size: 12px;"><img src="http://images2015.cnblogs.com/blog/966404/201609/966404-20160905094734488-1358193128.png" alt="" width="508" height="328"/></span></p><p><span style="font-family: 宋体; font-size: 12px; line-height: 1.5;">5.PHPnow</span></p><p><span style="font-size: 12px; font-family: 宋体;"></span></p><p><span style="font-size: 12px; font-family: 宋体;">http://www.phpnow.org/</span><br/><span style="font-size: 12px; font-family: 宋体;">国内研发，集成套件，绿色免费，简易安装、可快速搭建支持虚拟主机的PHP环境。</span></p><h3><span style="font-size: 12px; font-family: 宋体;">6.Easy2PHP</span></h3><p><span style="font-size: 12px; font-family: 宋体;"></span></p><p><span style="font-size: 12px; font-family: 宋体;">官方网站已经过期，下载地址请自行搜索（推荐：http://www.greendown.cn/soft/8254.html）</span><br/><span style="font-size: 12px; font-family: 宋体;">国内研发，Windows下的Apache+PHP+MySQL+Zend+phpMyAdmin的绿色环境套件，免安装，几秒钟即可搭建你自己的Web服务器。</span></p><h3><span style="font-size: 12px; font-family: 宋体;">7.ComsenzEXP</span></h3><p><span style="font-size: 12px; font-family: 宋体;"></span></p><p><span style="font-size: 12px; font-family: 宋体;">http://www.comsenz.com/downloads/install/exp</span><br/><span style="font-size: 12px; font-family: 宋体;">国内研发，是康盛创想开发的一套社区产品整合体验安装包，ComsenzEXP包括：Discuz!（论坛）、SupeSite（CMS）、UCenter（用户中心）、UCenter Home（SNS社区）。</span></p><h3><span style="font-size: 12px; font-family: 宋体;">8.DedeAMPZ-PHP环境整合套件</span></h3><p><span style="font-size: 12px; font-family: 宋体;"></span></p><p><span style="font-size: 12px; font-family: 宋体;">http://www.dedecms.com/html/chanpinxiazai/20080905/39481.html</span><br/><span style="font-size: 12px; font-family: 宋体;">国内研发，直接整合PHP+Apache+MySql的服务器环境管理软件，操作十分傻瓜化，适合初中级水平的站长使用。该套装默认搭载dedecms，安装使用十分简单，并支持在php4与php5中切换。同样也可以调试其他PHP程序，只要放在wwwroot目录中即可。</span></p><h3><span style="font-size: 12px;">&nbsp;</span><span style="font-size: 12px; font-family: 宋体;">9.AppServ</span></h3><p><span style="font-size: 12px; font-family: 宋体;"></span></p><p><span style="font-size: 12px; font-family: 宋体;">http://www.appservnetwork.com/</span><br/><span style="font-size: 12px; font-family: 宋体;">泰国研发，一些网络上免费的架站资源重新包装成单一的安装程序，是PHP网页架站工具组合包，方便PHP初学者快速完成架站。</span></p><h2><span style="font-size: 12px; font-family: 宋体;">手动安装PHP运行环境方法</span></h2><p><span style="font-size: 12px; font-family: 宋体;">一般来说PHP运行环境需要安装以下几个组件：</span></p><p><span style="font-size: 12px; font-family: 宋体;">1.Apache（阿帕奇）Web服务器软件；</span></p><p><span style="font-size: 12px; font-family: 宋体;">2.MySQL（小型关系型数据库管理系统）；</span></p><p><span style="font-size: 12px; font-family: 宋体;">3.PHP（php语言的编译环境）；</span></p><p><span style="font-size: 12px; font-family: 宋体;">4：phpmyadmin（管理MYSQL的）；</span></p><p><span style="font-size: 12px; font-family: 宋体;">5.Zend（提高PHP执行速度）。</span></p><h2><span style="font-size: 12px; font-family: 宋体;">安装PHP常见问题</span></h2><p><span style="font-size: 12px; font-family: 宋体;">如果某些这样的PHP相关的服务无法启动，请注意一下你的机器中的80端口是否被占用，检查80端口是否被占用的方法：打开CMD（开始－运行－输入CMD后回车），输入netstat -ano就可以很清楚的看到本地80口占用程序的PID。</span></p><p><br/></p>";s:7:"picture";s:0:"";s:11:"createdtime";s:10:"1497972477";s:8:"category";s:9:"1000,1111";s:7:"chapter";s:14:"4000,4007,4008";s:8:"nickname";s:5:"gw123";s:6:"avatar";s:26:"/images/default/avatar.png";s:8:"desc_len";s:1:"0";s:8:"body_len";s:4:"1376";s:10:"status_len";s:1:"1";s:11:"createdTime";s:10:"1497972477";s:6:"userId";s:1:"1";}i:3;a:20:{s:2:"id";s:3:"232";s:2:"pv";s:2:"22";s:10:"collectnum";s:1:"0";s:5:"title";s:17:"Html5设计原理";s:6:"userid";s:1:"1";s:8:"promoted";s:1:"3";s:10:"categoryid";s:1:"0";s:4:"desc";s:0:"";s:4:"body";s:10841:"<p>&nbsp;&nbsp;&nbsp;&nbsp;总结自Jeremy Keith在 Fronteers 2010 上的主题演讲。</p><p>&nbsp;&nbsp;&nbsp; 这里要讲的只是<a title="HTML5知识库" target="_blank" href="http://www.xytschool.com/index/detal?id=1600">HTML5</a>，并不包含<a title="CSS3知识库" target="_blank" href="http://www.xytschool.com/index/detal?id=1600">CSS3</a>，而且讲的不是html5包含什么，而是讲为什么会包含它们。即<a title="HTML5知识库" target="_blank" href="http://www.xytschool.com/index/detal?id=1600">Html5</a>的设计原理。<strong><br/></strong></p><p><strong>&nbsp;&nbsp;&nbsp;&nbsp;设计原理</strong> 本质上是一种信念、一种想法、一个概念，是你行动的支柱。不管你是制定规范，还是制造一种有形的物品，或者编写软件，甚至发明编程语言。你都能找到背后的一个或者多个设计原理，多人协作的任何成果都是例证。</p><p><strong>&nbsp;&nbsp;&nbsp;&nbsp;伯斯塔尔法则（Postel’s Law）</strong>：发送时要保守；接收时要开放。什么意思呢？意思就是，作为专业人士，在发送文档的时候，我们会尽量保守一些，尽量采用最佳实践，尽量确保文档格式良好。但从浏览器的角度说，它们必须以<strong>开放</strong>的姿态去接收任何文档。</p><p>好了，下面说一下设计原理吧。</p><h1><a target="_blank"></a>设计原理</h1><h2><a target="_blank"></a>1、避免不必要的复杂性</h2><p>这个很简单，举个例子来说</p><pre class="prettyprint">&lt;!DOCTYPE&nbsp;html&gt;</pre><p>HTML5只要这样写doctype就可以了，那么之前呢，拿之前的HTML4.01来说，</p><pre class="prettyprint">1&nbsp;&lt;!DOCTYPE&nbsp;html&nbsp;PUBLIC&nbsp;&quot;-//W3C/DTD&nbsp;HTML&nbsp;4.01//EN&quot;&nbsp;&quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;</pre><p>这么一长串根本记不住！</p><p><strong>那么，doctype是用来干什么的呢，为什么在文档开始就要写doctype呢？</strong></p><blockquote><p>回答一下上面的问题： <br/>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;它不是写给浏览器看的。Doctype 是写给验证器看的。也就是说，我之所以要在文档一开头写那行 
doctype，是为了告诉验证器，让验证器按照该 
doctype来验证我的文档。浏览器在接收的时候必须要开放。因此，它不会检查任何格式类型，而验证器会，验证器才关心格式类型。这才是存在 
doctype&gt; 的真正原因。 <br/>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而按照 HTML5 的另一个设计原理， 它必须<strong>向前向后兼容</strong>， 兼容未来的 HTML 版本——不管是 HTML6、HTML7，还是其他什么——都要与当前的 HTML 版本，HTML5，兼容。因此，把一个版本号放在 doctype 里面没有多大的意义，即使对验器证也一样。</p></blockquote><p><strong>在页面上加入了doctype，就相当于声明了“我想使用标准模式”</strong> </p><h2><a target="_blank"></a>2、支持已有内容</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们都会考虑让 Web 的未来发展得更好，但他们则必须考虑过去。别忘了 W3C 这个工作组中有很多人代表的是浏览器厂商， 他们肯定是要考虑支持已有内容的。 只要你想构建一款浏览器，就必须记住这个原则：必须支持已有的内容。 <br/>举个例子：</p><pre class="prettyprint">&lt;img&nbsp;src=&quot;foo&quot;&nbsp;alt=&quot;bar&quot;&nbsp;/&gt;&lt;p&nbsp;class=&quot;foo&quot;&gt;Hello&nbsp;world&lt;/p&gt;
&lt;img&nbsp;src=&quot;foo&quot;&nbsp;alt=&quot;bar&quot;&gt;&lt;p&nbsp;class=&quot;foo&quot;&gt;Hello&nbsp;world&lt;IMG&nbsp;SRC=&quot;foo&quot;&nbsp;ALT=&quot;bar&quot;&gt;
&lt;P&nbsp;CLASS=&quot;foo&quot;&gt;Hello&nbsp;world&lt;/P&gt;&lt;img&nbsp;src=foo&nbsp;alt=bar&gt;
&lt;p&nbsp;class=foo&gt;Hello&nbsp;world&lt;/p&gt;</pre><p>这个例子展示了编写同样内容的四种不同方式。上面是一个 img 
元素，下面是带一个属性的段落元素。四种写法唯一的不同点就是语法。把其中任何一段代码交给浏览器，浏览器都会生成相同的 DOM 
树，没有任何问题。从浏览器的角度看，这四种写法没有区别。因而在HTML5 中，你可以随意使用上述任何语法，但是， <br/><strong>这不意味着拒绝粗心大意的标记，做不做清理完全取决于你自己。</strong></p><h2><a target="_blank"></a>3、解决现实问题</h2><p>举个例子： <br/>假设我使用 HTML 4 或 XHTML 1，页面中已经有了一块内容， 我想给整块内容加个链接， 
怎么办？问题是这块内容里包含一个标题，一个段落，也许还有一张图片。如果我想给它们全部都可以点击，必须使用 3 
个链接元素。于是，我得先把光标放在标题（比如说 h2 
元素）中，写一个链接标签，然后再选中所有要包含到链接里面来的文本。接着，再把光标放在段落里，写一个链接标签，然后把段落中的文本放在链接里……</p><pre class="prettyprint">&lt;h2&gt;&lt;a&nbsp;href=&quot;/path/to/resource&quot;&gt;Headline&nbsp;text&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;&lt;a&nbsp;href=&quot;/path/to/resource&quot;&gt;Paragraph&nbsp;text.&lt;/a&gt;&lt;/p&gt;</pre><p>在 HTML5 中，我只要简单地把所有内容都包装在一个链接元素中就行了。</p><pre class="prettyprint">&lt;a&nbsp;href=&quot;/path/to/resource&quot;&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;h2&gt;Headline&nbsp;text&lt;/h2&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;p&gt;Paragraph&nbsp;text.&lt;/p&gt;
&lt;/a&gt;</pre><p>它解决了一个现实的问题,那这到底解决的是什么问题呢？浏览器不必因此重新写代码来支持这种写法。 
这种写法其实早就已经存在于浏览器中了，因为早就有人这样写了，当然以前这样写是不合乎规范的。所以，说 HTML5 
解决现实的问题，其本质还是“你都这样写了很多年了吧？现在我们把标准改了，允许你这样写了.</p><h2><a target="_blank"></a>4、求真务实</h2><p>HTML5 
中新的语义元素就是遵循求真务实原理的反映。新增的元素不算多，谈不上无限的扩展性，但却不失为一件好事。尽管数量屈指可数，但意义却非同一般。这些新元
素涉及头部（header）、脚部（footer）、分区（section）、文章（article）……，相信大家都不会觉得陌生。 <br/>举个例子，我们之前写文档，可能是这样来写：</p><pre class="prettyprint">&lt;body&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;id=&quot;header&quot;&gt;...&lt;/div&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;id=&quot;navigation&quot;&gt;...&lt;/div&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;id=&quot;main&quot;&gt;...&lt;/div&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;id=&quot;sidebar&quot;&gt;...&lt;/div&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;id=&quot;footer&quot;&gt;...&lt;/div&gt;
&lt;/body&gt;</pre><p>但现在，HTML5让我们可以这样写：</p><pre class="prettyprint">&lt;body&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;header&gt;...&lt;/header&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;nav&gt;...&lt;/nav&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&gt;...&lt;/div&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;aside&gt;...&lt;/aside&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;footer&gt;...&lt;/footer&gt;
&lt;/body&gt;</pre><p>这些新标记可以看作是类的替代品。 为什么这么说呢？因为这些元素在一个页面中不止可以使用一次， 
而是可以使用多次。没错，你可以为文档添加一个头部（header），再添加一个脚部（footer）；但文档中的每个分区（section）照样也都可
以有一个头部和一个脚部。而每个分区里还可以嵌套另一个分区，被嵌套的分区仍然可以有自己的头部和脚部。</p><p><strong>section &nbsp;article aside nav 很强大的标记，那么它们强大的原因是什么？</strong></p><blockquote><p>之所以说它们强大，原因在于它们代表了一种新的内容模型，一种 HTML 中前所未有的内容模型——给内容分区。 &nbsp;<br/>
 &nbsp;迄今为止，我们一直都在用 div 来组织页面中的内容，但与其他类似的元素一样，div 
本身并没有语义。但section、article、aside 和 nav 
实际上是在明确地告诉你——这一块就像文档中的另一个文档一样。位于这些元素中的任何内容，都可以拥有自己的概要、标题，自己的脚部。其中最为通用的 
section， 可以说是与内容最相关的一个。 而 article 则是一种特殊的 section。Aside 呢，是一种特殊的 
section。最后，Nav 也是一种特殊的 section。</p><p><strong>每个分区都是独立的，并且可以嵌套</strong></p></blockquote><h2><a target="_blank"></a>5、平稳退化</h2><p>有关 HTML5 遵循这条原理的例子，就是使用 type 属性增强表单。HTML5可以为 type属性指定的新值，有 
number、search、range，等等，最关键的问题在于浏览器在看到这些新 type 值时会如何处理。有的浏览器是无法理解这些新 type
 值的。 但在它们看到自己不理解的 type 值时，会将 type 的值解释为 text。这就是平稳退化。</p><p>还有就是video元素。video是非常贴心的元素，而且设计又简单，又实用。一个开始的 video 元素，加一个结束的 video 元素，中间可以放后备内容。</p><pre class="prettyprint">&lt;video&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;source&nbsp;src=&quot;movie.mp4&quot;&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;source&nbsp;src=&quot;movie.ogv&quot;&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;object&nbsp;data=&quot;movie.swf&quot;&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;a&nbsp;href=&quot;movie.mp4&quot;&gt;download&lt;/a&gt;
&nbsp;&nbsp;&nbsp;&nbsp;&lt;/object&gt;
&lt;/video&gt;</pre><p>上面的代码中包含了 4 个不同的层次。 <br/>1、如果浏览器支持 video 元素，也支持 H264，没什么好说的，用第一个视频。 <br/>2、如果浏览器支持 video 元素，支持 Ogg，那么用第二个视频。 <br/>3、如果浏览器不支持 video 元素，那么就要试试 Flash 影片了。 <br/>4、如果浏览器不支持 video 元素，也不支持 Flash，我还给出了下载链接。</p><h2><a target="_blank"></a>6、最终用户优先</h2><p><strong>一旦遇到冲突，最终用户优先，其次是作者，其次是实现者，其次标准制定者，最后才是理论上的完满。</strong></p><p>最终用户就是用户，作者是指开发者，实现者是指浏览器，标准制定者就是W3C等工作组。代码必然会反映作者的选择、偏见和期望。</p><p><br/></p>";s:7:"picture";s:0:"";s:11:"createdtime";s:10:"1497579079";s:8:"category";s:9:"1000,1112";s:7:"chapter";s:17:"11800,11801,11803";s:8:"nickname";s:5:"gw123";s:6:"avatar";s:26:"/images/default/avatar.png";s:8:"desc_len";s:1:"0";s:8:"body_len";s:4:"2937";s:10:"status_len";s:1:"1";s:11:"createdTime";s:10:"1497579079";s:6:"userId";s:1:"1";}i:4;a:20:{s:2:"id";s:3:"244";s:2:"pv";s:2:"18";s:10:"collectnum";s:1:"0";s:5:"title";s:10:"PHP 变量";s:6:"userid";s:1:"1";s:8:"promoted";s:1:"1";s:10:"categoryid";s:1:"0";s:4:"desc";s:0:"";s:4:"body";s:5595:"<p><strong>一．ZendStudio两个小问题<br/></strong>1.新建文档的模板设置：<br/>Window &nbsp;-&gt; Preferences -&gt; PHP -&gt; Editor -&gt; Templates -&gt; New simple PHP &nbsp;file<br/>//这个可以修改每次新建文件的起始代码<br/>2.自动提示代码速度很慢：<br/>Window -&gt; Preferences -&gt; &nbsp;PHP -&gt; Editor -&gt; Content Assist -&gt;Auto Activation<br/>//将代码自动提示的速度500 &nbsp;设置成50</p><p><strong>二．在Web页面中嵌入PHP代码</strong><br/>&lt;?php<br/>echo &nbsp;&quot;&lt;p&gt;我的第一个PHP程序!&lt;/p&gt;&quot;;<br/>?&gt;<br/>简短风格：&lt;? echo &quot;&lt;p&gt;My PHP!&lt;/p&gt;&quot;; ?&gt;<br/></p><p>向浏览器中输出：<br/>echo()、print()、printf()、sprintf()<br/>echo、print、printf &nbsp;本身是函数，即函数()。但这里的输出函数可以省略括号，用空格+所需显示的字符串或变量。<br/>echo 和print 功能几乎相同，而echo &nbsp;运行速度上比print 稍稍快一点。因为print 有返回值。<br/>//echo 不返回任何值(void),print &nbsp;返回的是整型(integer)<br/>printf()和sprintf()是C 语言模式，例如:printf(&quot;我今天买了%d &nbsp;套视频光盘&quot;,5);<br/>//他们之间的不同点是,printf 返回的是整型(integer)，而sprintf &nbsp;返回的字符串(string)<br/>//printf 可以在浏览器直接输出，而sprintf 需要echo 将它输出</p><p><img src="/files/image/20170622/1498102573525932.png" title="1498102573525932.png" alt="图片.png" width="589" height="248"/></p><p><strong>三．标识符与变量</strong><br/>标识符是变量的名称，关于标识符，PHP &nbsp;定义了一些简单的规则：<br/>·标识符可以是任何长度，而且可以由任何字母、数字、下划线组成。<br/>·标识符不能以数字开始。<br/>·在PHP &nbsp;中，标识符是区分大小写的。<br/>·一个变量名称可以与一个函数名称相同。</p><p><strong>变量赋值：</strong><br/>$sum=0;<br/>$total=1.22;<br/>$sum=$total;<br/><strong>变量的数据类型</strong><br/>PHP &nbsp;支持如下所示的基本数据类型：<br/>Integer(整数)、Float(浮点数，也叫Double,双精度)、String(字符串)、Boole &nbsp;an(布尔)、Array(数组)、Object(对象).</p><p><strong>类型强度</strong><br/>PHP &nbsp;是一种非常弱的类型语言。在大多数编程语言中，变量只能保存一种类型的数据，而且这个类型必须在使用变量之前声明。而在PHP &nbsp;中，变量的类型是由赋值给变量的值确定的。</p><p><strong>类型转换</strong><br/>使用类型转换，可以将一个变量或值转换成另一种类型。<br/>$sum=0;<br/>$total=(float)$sum;</p><p><strong>检测变量</strong><br/>大部分的可变函数都是用来测试一个函数的类型的。PHP &nbsp;中有两个最常见的函数，<br/>分别是gettype()和settype()。<br/>这两个函数返回的string 类型，也就是变量的类型字符串。</p><p>isset()和unset()用来判断一个变量是否存在，返回的是布尔值true &nbsp;或false。<br/>empty()用来判断一个变量的值是否为空，如果为空则为true &nbsp;否则为false。<br/>换句话说，&quot;&quot;、0、&quot;0&quot;、NULL、FALSE、array()、var $var; &nbsp;以及没有任何属性的对象都将被认为是空的PHP还提供了一些特定类型的测试函数。每一个函数都使用一个变量座位其参数，并且返回true 或false。<br/>&nbsp;</p><p>is_array()、is_double()、is_float()、is_real()、is_long()、is_int()、is_integer()、is_string()、<br/>is_object()、is_resource()、is_null()、is_numeric()<br/>可以通过调用一个函数来实现转换变量数据类型的目的。<br/>intval()、floatval()、strval();</p><p><strong>理解变量的作用域</strong><br/>作用域是指在一个脚本中某个变量在哪些地方可以使用或可见。<br/>内置超级全局变量可以在脚本的任何地方使用和可见。<br/>常量，一旦被声明，将可以在全局可见。也就是说，他们可以在函数内外使用。<br/>在一个脚本中声明的全局变量在整个脚本中是可见的，但不是在函数内部。<br/>函数内部使用的变量声明为全局变量时，其名称要与全局变量名称一致。<br/>在函数内部创建并被声明为静态的变量无法在函数外部可见，但是可以在函数的多次多次执行过程中保持改值<br/>在函数内部创建的变量对函数来说是本地的，而当函数终止时，该变量也就不存在了</p><p><strong>超级全局变量：</strong><br/>$GLOBALS&nbsp; 所有全局变量数组<br/>$_SERVER&nbsp; 服务器环境变量数组<br/>$_GET &nbsp;&nbsp; 通过GET 方法传递给该脚本的变量数组<br/>$_POST 通过POST 方法传递给该脚本的变量数组</p><p>$_COOKIE&nbsp; cookie &nbsp;变量数组<br/>$_FILES&nbsp; 与文件上载相关的变量数组<br/>$_ENV&nbsp;&nbsp; 环境变量数组<br/>$_REQUEST &nbsp;所有用户输入的变量数组<br/>$_SESSION 会话变量数组</p><p><strong>常量</strong><br/>常量一旦被定义之后，就不能再次更改。<br/>define(&quot;TOTAL&quot;,199);<br/>除了自定义常量外，PHP &nbsp;还预定了许多常量。了解这些常量的简单方法就是运行<br/>phpinfo()命令。<br/>变量和常量的另一个差异在于常量只可以保存布尔值、整数、浮点数或字符串数据。<br/>这些类型都是标量数据。 不过在php7以后产量是可以保存数组的.<br/></p><p><br/></p><br/><p><br/></p>";s:7:"picture";s:0:"";s:11:"createdtime";s:10:"1498103338";s:8:"category";s:9:"1000,1111";s:7:"chapter";s:14:"4000,4015,4016";s:8:"nickname";s:5:"gw123";s:6:"avatar";s:26:"/images/default/avatar.png";s:8:"desc_len";s:1:"0";s:8:"body_len";s:4:"1537";s:10:"status_len";s:1:"1";s:11:"createdTime";s:10:"1498103338";s:6:"userId";s:1:"1";}i:5;a:20:{s:2:"id";s:3:"229";s:2:"pv";s:2:"17";s:10:"collectnum";s:1:"0";s:5:"title";s:33:"PHP不能不看的50个细节！.";s:6:"userid";s:1:"1";s:8:"promoted";s:1:"1";s:10:"categoryid";s:4:"1111";s:4:"desc";s:0:"";s:4:"body";s:7800:"<p>1、用单引号代替双引号来包含字符串，这样做会更快一些。因为PHP会在双引号包围的字符串中搜寻变量， 单引号则不会，注意：只有echo能这么做，它是一种可以把多个字符串当作参数的”函数”(译注：PHP手册中说echo是语言结构，不是真正的函数，故把函数加上了双引号)。</p><p><br/>2、如果能将类的方法定义成static，就尽量定义成static，它的速度会提升将近4倍。<br/><br/>3、$row[‘id’] 的速度是$row[id]的7倍。<br/><br/>4、echo 比 print 快，并且使用echo的多重参数(译注：指用逗号而不是句点)代替字符串连接，比如echo $str1,$str2。<br/><br/>5、在执行for循环之前确定最大循环数，不要每循环一次都计算最大值，最好运用foreach代替。<br/><br/>6、注销那些不用的变量尤其是大数组，以便释放内存。<br/><br/>7、尽量避免使用__get，__set，__autoload。<br/><br/>8、require_once()代价昂贵。<br/><br/>9、include文件时尽量使用绝对路径，因为它避免了PHP去include_path里查找文件的速度，解析操作系统路径所需的时间会更少。<br/><br/>10、如果你想知道脚本开始执行(译注：即服务器端收到客户端请求)的时刻，使用$_SERVER[‘REQUEST_TIME’]要好于time()<br/><br/>11、函数代替正则表达式完成相同功能。<br/><br/>12、str_replace函数比preg_replace函数快，但strtr函数的效率是str_replace函数的四倍。<br/><br/>13、如果一个字符串替换函数，可接受数组或字符作为参数，并且参数长度不太长，那么可以考虑额外写一段替换代码，使得每次传递参数是一个字符，而不是只写一行代码接受数组作为查询和替换的参数。<br/><br/>14、使用选择分支语句(译注：即switch case)好于使用多个if，else if语句。<br/><br/>15、用@屏蔽错误消息的做法非常低效，极其低效。<br/><br/>16、打开apache的mod_deflate模块，可以提高网页的浏览速度。<br/><br/>17、数据库连接当使用完毕时应关掉，不要用长连接。<br/><br/>18、错误消息代价昂贵。<br/><br/>19、在方法中递增局部变量，速度是最快的。几乎与在函数中调用局部变量的速度相当。<br/><br/>20、递增一个全局变量要比递增一个局部变量慢2倍。<br/><br/>21、递增一个对象属性(如：$this-&gt;prop++)要比递增一个局部变量慢3倍。<br/><br/>22、递增一个未预定义的局部变量要比递增一个预定义的局部变量慢9至10倍。<br/><br/>23、仅定义一个局部变量而没在函数中调用它，同样会减慢速度(其程度相当于递增一个局部变量)。PHP大概会检查看是否存在全局变量。<br/><br/>24、方法调用看来与类中定义的方法的数量无关，因为我(在测试方法之前和之后都)添加了10个方法，但性能上没有变化。<br/><br/>25、派生类中的方法运行起来要快于在基类中定义的同样的方法。<br/><br/>26、调用带有一个参数的空函数，其花费的时间相当于执行7至8次的局部变量递增操作。类似的方法调用所花费的时间接近于15次的局部变量递增操作。<br/><br/>27、Apache解析一个PHP脚本的时间要比解析一个静态HTML页面慢2至10倍。尽量多用静态HTML页面，少用脚本。<br/><br/>28、除非脚本可以缓存，否则每次调用时都会重新编译一次。引入一套PHP缓存机制通常可以提升25%至100%的性能，以免除编译开销。<br/><br/>29、尽量做缓存，可使用memcached。memcached是一款高性能的内存对象缓存系统，可用来加速动态Web应用程序，减轻数据库负载。对运算码 (OP code)的缓存很有用，使得脚本不必为每个请求做重新编译。<br/><br/>30、当操作字符串并需要检验其长度是否满足某种要求时，你想当然地会使用strlen()函数。此函数执行起来相当快，因为它不做任何计算， 只返回在zval 结构(C的内置数据结构，用于存储PHP变量)中存储的已知字符串长度。但是，由于strlen()是函数，多多少少会有些慢，因为函数调用会经过诸多步 骤，如字母小写化(译注：指函数名小写化，PHP不区分函数名大小写)、哈希查找，会跟随被调用的函数一起执行。在某些情况下，你可以使用isset() 技巧加速执行你的代码。<br/>(举例如下)<br/>if (strlen($foo) &lt; 5) { echo “Foo is too short”$$ }<br/>(与下面的技巧做比较)<br/>if (!isset($foo{5})) { echo “Foo is too short”$$ }<br/>调用isset()恰巧比strlen()快，因为与后者不同的是，isset()作为一种语言结构，意味着它的执行不需要函数查找和字母小写化。也就是说，实际上在检验字符串长度的顶层代码中你没有花太多开销。<br/><br/>31、当执行变量$i的递增或递减时，$i++会比++$i慢一些。这种差异是PHP特有的，并不适用于其他语言，所以请不要修改你的C或 Java代码并指望它们能立即变快，没用的。++$i更快是因为它只需要3条指令(opcodes)，$i++则需要4条指令。后置递增实际上会产生一个 临时变量，这个临时变量随后被递增。而前置递增直接在原值上递增。这是最优化处理的一种，正如Zend的PHP优化器所作的那样。牢记这个优化处理不失为 一个好主意，因为并不是所有的指令优化器都会做同样的优化处理，并且存在大量没有装配指令优化器的互联网服务提供商(ISPs)和服务器。<br/><br/>32、并不是事必面向对象(OOP)，面向对象往往开销很大，每个方法和对象调用都会消耗很多内存。<br/><br/>33、并非要用类实现所有的数据结构，数组也很有用。<br/><br/>34、不要把方法细分得过多，仔细想想你真正打算重用的是哪些代码?<br/><br/>35、当你需要时，你总能把代码分解成方法。<br/><br/>36、尽量采用大量的PHP内置函数。<br/><br/>37、如果在代码中存在大量耗时的函数，你可以考虑用C扩展的方式实现它们。<br/><br/>38、评估检验(profile)你的代码。检验器会告诉你，代码的哪些部分消耗了多少时间。Xdebug调试器包含了检验程序，评估检验总体上可以显示出代码的瓶颈。<br/><br/>39、mod_zip可作为Apache模块，用来即时压缩你的数据，并可让数据传输量降低80%。<br/><br/>40、在可以用file_get_contents替代file、fopen、feof、fgets等系列方法的情况下，尽量用 file_get_contents，因为他的效率高得多!但是要注意file_get_contents在打开一个URL文件时候的PHP版本问题；<br/></p><p><br/></p><p>41、尽量的少进行文件操作，虽然PHP的文件操作效率也不低的；<br/><br/>42、优化Select 
SQL语句，在可能的情况下尽量少的进行Insert、Update操作(在update上，我被恶批过)；<br/><br/>43、尽可能的使用PHP内部函数(但是我却为了找个PHP里面不存在的函数，浪费了本可以写出一个自定义函数的时间，经验问题啊!)；<br/><br/>44、循环内部不要声明变量，尤其是大变量：对象(这好像不只是PHP里面要注意的问题吧?)；<br/><br/>45、多维数组尽量不要循环嵌套赋值；<br/><br/>46、在可以用PHP内部字符串操作函数的情况下，不要用正则表达式；<br/><br/>47、foreach效率更高，尽量用foreach代替while和for循环；<br/><br/>48、用单引号替代双引号引用字符串；<br/><br/>49、”用i+=1代替i=i+1。符合c/c++的习惯，效率还高”；<br/><br/>50、对global变量，应该用完就unset()掉</p><p><br/> &nbsp;</p>";s:7:"picture";s:0:"";s:11:"createdtime";s:10:"1497540989";s:8:"category";s:9:"1000,1111";s:7:"chapter";s:4:"4200";s:8:"nickname";s:5:"gw123";s:6:"avatar";s:26:"/images/default/avatar.png";s:8:"desc_len";s:1:"0";s:8:"body_len";s:4:"2436";s:10:"status_len";s:1:"1";s:11:"createdTime";s:10:"1497540989";s:6:"userId";s:1:"1";}i:6;a:20:{s:2:"id";s:3:"230";s:2:"pv";s:2:"17";s:10:"collectnum";s:1:"0";s:5:"title";s:10:"HTTP简介";s:6:"userid";s:1:"1";s:8:"promoted";s:1:"1";s:10:"categoryid";s:1:"1";s:4:"desc";s:0:"";s:4:"body";s:37344:"<p style="color: rgb(51, 51, 51); font-family: Georgia,&quot;font-size:14px;background-color:#FFFFFF;&quot;; margin-top: 5px;"><span style="color: #000000; line-height: 1.8; font-size: x-small; font-family: 宋体,SimSun;"><strong><span style="color: #000000; line-height: 1.8; font-size: small;">引言</span></strong><span style="color: #000000; line-height: 1.8; font-size: small;"><br/></span></span></p><p style="color:#333333;font-family:Georgia, &quot;font-size:14px;background-color:#FFFFFF;"><span style="color: #000000; line-height: 1.8; font-family: 宋体,SimSun; font-size: 14px;">HTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于1990年提出，经过几年的使用与发展，得到不断地完善和扩展。目前在WWW中使用的是HTTP/1.0的第六版，HTTP/1.1的规范化工作正在进行之中，而且HTTP-NG(Next Generation of HTTP)的建议已经提出。<br/>HTTP协议的主要特点可概括如下：<br/>1.支持客户/服务器模式。<br/>2.简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。<br/>3.灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。<br/>4.无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。<br/>5.无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</span></p><p style="color:#333333;font-family:Georgia, &quot;font-size:14px;background-color:#FFFFFF;"><span style="font-family: 宋体,SimSun;">
	&nbsp;</span></p><p style="color:#333333;font-family:Georgia, &quot;font-size:14px;background-color:#FFFFFF;"><span style="font-family: 宋体,SimSun;"><strong><span style="font-family: 宋体,SimSun; line-height: 1.8; color: #000000;">一、HTTP协议详解之URL篇</span></strong><strong><span style="font-family: 宋体,SimSun; line-height: 1.8; color: #000000;"></span></strong></span></p><p style="color:#333333;font-family:Georgia, &quot;font-size:14px;background-color:#FFFFFF;"><span style="line-height: 1.8; color: #000000; font-family: 宋体,SimSun;">&nbsp; <span style="line-height: 1.8; color: #000000; font-family: 宋体,SimSun; font-size: 14px;">http（超文本传输协议）是一个基于请求与响应模式的、无状态的、应用层的协议，常基于TCP的连接方式，HTTP1.1版本中给出一种持续连接的机制，绝大多数的Web开发，都是构建在HTTP协议之上的Web应用。</span></span></p><p style="color:#333333;font-family:Georgia, &quot;font-size:14px;background-color:#FFFFFF;"><span style="font-size: 14px;"><span style="font-size: 14px; line-height: 1.8; color: #000000; font-family: 宋体,SimSun;">HTTP URL (URL是一种特殊类型的URI，包含了用于查找某个资源的足够的信息)的格式如下：<br/>http://host[&quot;:&quot;port][abs_path]<br/>http表示要通过HTTP协议来定位网络资源；host表示合法的Internet主机域名或者IP地址；port指定一个端口号，为空则使用缺省端口80；abs_path指定请求资源的URI；如果URL中没有给出abs_path，那么当它作为请求URI时，必须以“/”的形式给出，通常这个工作浏览器自动帮我们完成。eg:<br/>1、输入：www.guet.edu.cn</span><br/><span style="font-size: 14px; line-height: 1.8; color: #000000; font-family: 宋体,SimSun;">浏览器自动转换成：http://www.guet.edu.cn/</span><br/><span style="font-size: 14px; line-height: 1.8; color: #000000; font-family: 宋体,SimSun;">2、http:192.168.0.116:8080/index.jsp&nbsp;</span></span></p><p style="color:#333333;font-family:Georgia, &quot;font-size:14px;background-color:#FFFFFF;"><span style="font-family: 宋体,SimSun;">
	&nbsp;</span></p><p style="color:#333333;font-family:Georgia, &quot;font-size:14px;background-color:#FFFFFF;"><span style="line-height: 1.8; color: #000000; font-family: 宋体,SimSun;"><strong>二、HTTP协议详解之请求篇</strong></span></p><p style="color:#333333;font-family:Georgia, &quot;font-size:14px;background-color:#FFFFFF;"><span style="line-height: 1.8; color: #000000; font-family: 宋体,SimSun;">&nbsp; <span style="line-height: 1.8; color: #000000; font-family: 宋体,SimSun; font-size: 14px;">http请求由三部分组成，分别是：请求行、消息报头、请求正文</span></span></p><p style="color:#333333;font-family:Georgia, &quot;font-size:14px;background-color:#FFFFFF;"><span style="line-height: 1.8; color: #000000; font-family: 宋体,SimSun; font-size: 14px;">1、请求行以一个方法符号开头，以空格分开，后面跟着请求的URI和协议的版本，格式如下：Method Request-URI HTTP-Version CRLF&nbsp;&nbsp;<br/>其中 Method表示请求方法；Request-URI是一个统一资源标识符；HTTP-Version表示请求的HTTP协议版本；CRLF表示回车和换行（除了作为结尾的CRLF外，不允许出现单独的CR或LF字符）。</span></p><p style="color:#333333;font-family:Georgia, &quot;font-size:14px;background-color:#FFFFFF;"><span style="line-height: 1.8; color: #000000; font-family: 宋体,SimSun; font-size: 14px;">请求方法（所有方法全为大写）有多种，各个方法的解释如下：<br/>GET&nbsp;&nbsp;&nbsp;&nbsp; 请求获取Request-URI所标识的资源<br/>POST&nbsp;&nbsp;&nbsp; 在Request-URI所标识的资源后附加新的数据<br/>HEAD&nbsp;&nbsp;&nbsp; 请求获取由Request-URI所标识的资源的响应消息报头<br/>PUT&nbsp;&nbsp;&nbsp;&nbsp; 请求服务器存储一个资源，并用Request-URI作为其标识<br/>DELETE&nbsp; 请求服务器删除Request-URI所标识的资源<br/>TRACE&nbsp;&nbsp; 请求服务器回送收到的请求信息，主要用于测试或诊断<br/>CONNECT 保留将来使用<br/>OPTIONS 请求查询服务器的性能，或者查询与资源相关的选项和需求<br/>应用举例：<br/>GET方法：在浏览器的地址栏中输入网址的方式访问网页时，浏览器采用GET方法向服务器获取资源，eg:GET /form.html HTTP/1.1 (CRLF)</span></p><p style="color:#333333;font-family:Georgia, &quot;font-size:14px;background-color:#FFFFFF;"><span style="line-height: 1.8; color: #000000; font-family: 宋体,SimSun; font-size: 14px;">POST方法要求被请求服务器接受附在请求后面的数据，常用于提交表单。<br/>eg：POST /reg.jsp HTTP/ (CRLF)<br/>Accept:image/gif,image/x-xbit,... (CRLF)<br/>...<br/>HOST:www.guet.edu.cn (CRLF)<br/>Content-Length:22 (CRLF)<br/>Connection:Keep-Alive (CRLF)<br/>Cache-Control:no-cache (CRLF)<br/>(CRLF)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //该CRLF表示消息报头已经结束，在此之前为消息报头<br/>user=jeffrey&amp;pwd=1234&nbsp; //此行以下为提交的数据</span></p><p style="color:#333333;font-family:Georgia, &quot;font-size:14px;background-color:#FFFFFF;"><span style="line-height: 1.8; color: #000000; font-family: 宋体,SimSun; font-size: 14px;">HEAD方法与GET方法几乎是一样的，对于HEAD请求的回应部分来说，它的HTTP头部中包含的信息与通过GET请求所得到的信息是相同的。利用这个方法，不必传输整个资源内容，就可以得到Request-URI所标识的资源的信息。该方法常用于测试超链接的有效性，是否可以访问，以及最近是否更新。<br/>2、请求报头后述<br/>3、请求正文(略)&nbsp;</span></p><p style="color:#333333;font-family:Georgia, &quot;font-size:14px;background-color:#FFFFFF;"><span style="font-family: 宋体,SimSun;">
	&nbsp;</span></p><p style="color:#333333;font-family:Georgia, &quot;font-size:14px;background-color:#FFFFFF;"><span style="line-height: 1.8; color: #000000; font-family: 宋体,SimSun;"><strong>三、HTTP协议详解之响应篇</strong></span></p><p style="color:#333333;font-family:Georgia, &quot;font-size:14px;background-color:#FFFFFF;"><span style="line-height: 1.8; color: #000000; font-family: 宋体,SimSun;">&nbsp; <span style="line-height: 1.8; color: #000000; font-family: 宋体,SimSun; font-size: 14px;">在接收和解释请求消息后，服务器返回一个HTTP响应消息。</span></span></p><p style="color:#333333;font-family:Georgia, &quot;font-size:14px;background-color:#FFFFFF;"><span style="line-height: 1.8; color: #000000; font-family: 宋体,SimSun; font-size: 14px;">HTTP响应也是由三个部分组成，分别是：状态行、消息报头、响应正文<br/>1、状态行格式如下：<br/>HTTP-Version Status-Code Reason-Phrase CRLF<br/>其中，HTTP-Version表示服务器HTTP协议的版本；Status-Code表示服务器发回的响应状态代码；Reason-Phrase表示状态代码的文本描述。<br/>状态代码有三位数字组成，第一个数字定义了响应的类别，且有五种可能取值：<br/>1xx：指示信息--表示请求已接收，继续处理<br/>2xx：成功--表示请求已被成功接收、理解、接受<br/>3xx：重定向--要完成请求必须进行更进一步的操作<br/>4xx：客户端错误--请求有语法错误或请求无法实现<br/>5xx：服务器端错误--服务器未能实现合法的请求<br/>常见状态代码、状态描述、说明：<br/>200 OK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //客户端请求成功<br/>400 Bad Request&nbsp; //客户端请求有语法错误，不能被服务器所理解<br/>401 Unauthorized //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用&nbsp;<br/>403 Forbidden&nbsp; //服务器收到请求，但是拒绝提供服务<br/>404 Not Found&nbsp; //请求资源不存在，eg：输入了错误的URL<br/>500 Internal Server Error //服务器发生不可预期的错误<br/>503 Server Unavailable&nbsp; //服务器当前不能处理客户端的请求，一段时间后可能恢复正常<br/>eg：HTTP/1.1 200 OK （CRLF）</span></p><p style="color:#333333;font-family:Georgia, &quot;font-size:14px;background-color:#FFFFFF;"><span style="line-height: 1.8; color: #000000; font-family: 宋体,SimSun; font-size: 14px;">2、响应报头后述</span></p><p style="color:#333333;font-family:Georgia, &quot;font-size:14px;background-color:#FFFFFF;"><span style="line-height: 1.8; color: #000000; font-family: 宋体,SimSun; font-size: 14px;">3、响应正文就是服务器返回的资源的内容&nbsp;</span></p><p style="color:#333333;font-family:Georgia, &quot;font-size:14px;background-color:#FFFFFF;"><span style="font-family: 宋体,SimSun;">
	&nbsp;</span></p><p style="color:#333333;font-family:Georgia, &quot;font-size:14px;background-color:#FFFFFF;"><span style="font-family: 宋体,SimSun;"><strong><span style="font-family: 宋体,SimSun; line-height: 1.8; color: #000000;">四、HTTP协议详解之消息报头篇</span></strong><strong><span style="font-family: 宋体,SimSun; line-height: 1.8; color: #000000;"></span></strong></span></p><p style="color:#333333;font-family:Georgia, &quot;font-size:14px;background-color:#FFFFFF;"><span style="line-height: 1.8; color: #000000; font-family: 宋体,SimSun;">&nbsp;&nbsp;&nbsp;<span style="line-height: 1.8; color: #000000; font-family: 宋体,SimSun; font-size: 14px;"> HTTP消息由客户端到服务器的请求和服务器到客户端的响应组成。请求消息和响应消息都是由开始行（对于请求消息，开始行就是请求行，对于响应消息，开始行就是状态行），消息报头（可选），空行（只有CRLF的行），消息正文（可选）组成。</span></span></p><p style="color:#333333;font-family:Georgia, &quot;font-size:14px;background-color:#FFFFFF;"><span style="line-height: 1.8; color: #000000; font-family: 宋体,SimSun; font-size: 14px;">HTTP消息报头包括普通报头、请求报头、响应报头、实体报头。<br/>每一个报头域都是由名字+“：”+空格+值 组成，消息报头域的名字是大小写无关的。</span></p><p style="color:#333333;font-family:Georgia, &quot;font-size:14px;background-color:#FFFFFF;"><span style="line-height: 1.8; color: #000000; font-family: 宋体,SimSun; font-size: 14px;">1、普通报头<br/>在普通报头中，有少数报头域用于所有的请求和响应消息，但并不用于被传输的实体，只用于传输的消息。<br/>eg：<br/>Cache-Control&nbsp;&nbsp; 用于指定<a href="http://www.php1.cn/category/79.html">缓存</a>指令，<a href="http://www.php1.cn/category/79.html">缓存</a>指令是单向的（响应中出现的<a href="http://www.php1.cn/category/79.html">缓存</a>指令在请求中未必会出现），且是独立的（一个消息的<a href="http://www.php1.cn/category/79.html">缓存</a>指令不会影响另一个消息处理的<a href="http://www.php1.cn/category/79.html">缓存</a>机制），HTTP1.0使用的类似的报头域为Pragma。<br/>请求时的<a href="http://www.php1.cn/category/79.html">缓存</a>指令包括：no-cache（用于指示请求或响应消息不能<a href="http://www.php1.cn/category/79.html">缓存</a>）、no-store、max-age、max-stale、min-fresh、only-if-cached;<br/>响应时的<a href="http://www.php1.cn/category/79.html">缓存</a>指令包括：public、private、no-cache、no-store、no-transform、must-revalidate、proxy-revalidate、max-age、s-maxage.<br/>eg：为了指示IE浏览器（客户端）不要<a href="http://www.php1.cn/category/79.html">缓存</a>页面，服务器端的JSP程序可以编写如下：response.sehHeader(&quot;Cache-Control&quot;,&quot;no-cache&quot;);<br/>//response.setHeader(&quot;Pragma&quot;,&quot;no-cache&quot;);作用相当于上述代码，通常两者//合用<br/>这句代码将在发送的响应消息中设置普通报头域：Cache-Control:no-cache</span></p><p style="color:#333333;font-family:Georgia, &quot;font-size:14px;background-color:#FFFFFF;"><br/><span style="line-height: 1.8; color: #000000; font-family: 宋体,SimSun; font-size: 14px;">Date普通报头域表示消息产生的日期和时间</span></p><p style="color:#333333;font-family:Georgia, &quot;font-size:14px;background-color:#FFFFFF;"><span style="line-height: 1.8; color: #000000; font-family: 宋体,SimSun; font-size: 14px;">Connection普通报头域允许发送指定连接的选项。例如指定连接是连续，或者指定“close”选项，通知服务器，在响应完成后，关闭连接</span></p><p style="color:#333333;font-family:Georgia, &quot;font-size:14px;background-color:#FFFFFF;"><span style="line-height: 1.8; color: #000000; font-family: 宋体,SimSun; font-size: 14px;">2、请求报头<br/>请求报头允许客户端向服务器端传递请求的附加信息以及客户端自身的信息。<br/>常用的请求报头<br/>Accept<br/>Accept请求报头域用于指定客户端接受哪些类型的信息。eg：Accept：image/gif，表明客户端希望接受GIF图象格式的资源；Accept：text/html，表明客户端希望接受html文本。<br/>Accept-Charset<br/>Accept-Charset请求报头域用于指定客户端接受的字符集。eg：Accept-Charset:iso-8859-1,gb2312.如果在请求消息中没有设置这个域，缺省是任何字符集都可以接受。<br/>Accept-Encoding<br/>Accept-Encoding请求报头域类似于Accept，但是它是用于指定可接受的内容编码。eg：Accept-Encoding:gzip.deflate.如果请求消息中没有设置这个域服务器假定客户端对各种内容编码都可以接受。<br/>Accept-Language<br/>Accept-Language请求报头域类似于Accept，但是它是用于指定一种自然语言。eg：Accept-Language:zh-cn.如果请求消息中没有设置这个报头域，服务器假定客户端对各种语言都可以接受。<br/>Authorization<br/>Authorization请求报头域主要用于证明客户端有权查看某个资源。当浏览器访问一个页面时，如果收到服务器的响应代码为401（未授权），可以发送一个包含Authorization请求报头域的请求，要求服务器对其进行验证。<br/>Host（发送请求时，该报头域是必需的）<br/>Host请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的，eg：<br/>我们在浏览器中输入：</span><span style="line-height: 1.8; color: #000000; font-family: 宋体,SimSun; font-size: 14px;">http://www.guet.edu.cn/index.html</span><br/><span style="line-height: 1.8; color: #000000; font-family: 宋体,SimSun; font-size: 14px;">浏览器发送的请求消息中，就会包含Host请求报头域，如下：<br/>Host：</span><span style="line-height: 1.8; color: #000000; font-family: 宋体,SimSun; font-size: 14px;">www.guet.edu.cn</span><br/><span style="line-height: 1.8; color: #000000; font-family: 宋体,SimSun; font-size: 14px;">此处使用缺省端口号80，若指定了端口号，则变成：Host：</span><span style="line-height: 1.8; color: #000000; font-family: 宋体,SimSun; font-size: 14px;">www.guet.edu.cn</span><span style="line-height: 1.8; color: #000000; font-family: 宋体,SimSun; font-size: 14px;">:指定端口号<br/>User-Agent<br/>我们上网登陆论坛的时候，往往会看到一些欢迎信息，其中列出了你的操作系统的名称和版本，你所使用的浏览器的名称和版本，这往往让很多人感到很神奇，实际上，服务器应用程序就是从User-Agent这个请求报头域中获取到这些信息。User-Agent请求报头域允许客户端将它的操作系统、浏览器和其它属性告诉服务器。不过，这个报头域不是必需的，如果我们自己编写一个浏览器，不使用User-Agent请求报头域，那么服务器端就无法得知我们的信息了。<br/>请求报头举例：<br/>GET /form.html HTTP/1.1 (CRLF)<br/>Accept:image/gif,image/x-xbitmap,image/jpeg,application/x-shockwave-flash,application/vnd.ms-excel,application/vnd.ms-powerpoint,application/msword,*/* (CRLF)<br/>Accept-Language:zh-cn (CRLF)<br/>Accept-Encoding:gzip,deflate (CRLF)<br/>If-Modified-Since:Wed,05 Jan 2007 11:21:25 GMT (CRLF)<br/>If-None-Match:W/&quot;80b1a4c018f3c41:8317&quot; (CRLF)<br/>User-Agent:Mozilla/4.0(compatible;MSIE6.0;Windows NT 5.0) (CRLF)<br/>Host:www.guet.edu.cn (CRLF)<br/>Connection:Keep-Alive (CRLF)<br/>(CRLF)</span></p><p style="color:#333333;font-family:Georgia, &quot;font-size:14px;background-color:#FFFFFF;"><span style="line-height: 1.8; color: #000000; font-family: 宋体,SimSun; font-size: 14px;">3、响应报头<br/>响应报头允许服务器传递不能放在状态行中的附加响应信息，以及关于服务器的信息和对Request-URI所标识的资源进行下一步访问的信息。<br/>常用的响应报头<br/>Location<br/>Location响应报头域用于重定向接受者到一个新的位置。Location响应报头域常用在更换域名的时候。<br/>Server<br/>Server响应报头域包含了服务器用来处理请求的软件信息。与User-Agent请求报头域是相对应的。下面是<br/>Server响应报头域的一个例子：<br/>Server：Apache-Coyote/1.1<br/>WWW-Authenticate<br/>WWW-Authenticate响应报头域必须被包含在401（未授权的）响应消息中，客户端收到401响应消息时候，并发送Authorization报头域请求服务器对其进行验证时，服务端响应报头就包含该报头域。<br/>eg：WWW-Authenticate:Basic realm=&quot;Basic Auth Test!&quot;&nbsp; //可以看出服务器对请求资源采用的是基本验证机制。</span></p><p style="color:#333333;font-family:Georgia, &quot;font-size:14px;background-color:#FFFFFF;"><br/><span style="line-height: 1.8; color: #000000; font-family: 宋体,SimSun; font-size: 14px;">4、实体报头<br/>请求和响应消息都可以传送一个实体。一个实体由实体报头域和实体正文组成，但并不是说实体报头域和实体正文要在一起发送，可以只发送实体报头域。实体报头定义了关于实体正文（eg：有无实体正文）和请求所标识的资源的元信息。<br/>常用的实体报头<br/>Content-Encoding<br/>Content-Encoding实体报头域被用作媒体类型的修饰符，它的值指示了已经被应用到实体正文的附加内容的编码，因而要获得Content-Type报头域中所引用的媒体类型，必须采用相应的解码机制。Content-Encoding这样用于记录文档的压缩方法，eg：Content-Encoding：gzip<br/>Content-Language<br/>Content-Language实体报头域描述了资源所用的自然语言。没有设置该域则认为实体内容将提供给所有的语言阅读<br/>者。eg：Content-Language:da<br/>Content-Length<br/>Content-Length实体报头域用于指明实体正文的长度，以字节方式存储的十进制数字来表示。<br/>Content-Type<br/>Content-Type实体报头域用语指明发送给接收者的实体正文的媒体类型。eg：<br/>Content-Type:text/html;charset=ISO-8859-1<br/>Content-Type:text/html;charset=GB2312<br/>Last-Modified<br/>Last-Modified实体报头域用于指示资源的最后修改日期和时间。<br/>Expires<br/>Expires实体报头域给出响应过期的日期和时间。为了让代理服务器或浏览器在一段时间以后更新<a href="http://www.php1.cn/category/79.html">缓存</a>中(再次访问曾访问过的页面时，直接从<a href="http://www.php1.cn/category/79.html">缓存</a>中加载，缩短响应时间和降低服务器负载)的页面，我们可以使用Expires实体报头域指定页面过期的时间。eg：Expires：Thu，15 Sep 2006 16:23:12 GMT<br/>HTTP1.1的客户端和<a href="http://www.php1.cn/category/79.html">缓存</a>必须将其他非法的日期格式（包括0）看作已经过期。eg：为了让浏览器不要<a href="http://www.php1.cn/category/79.html">缓存</a>页面，我们也可以利用Expires实体报头域，设置为0，jsp中程序如下：response.setDateHeader(&quot;Expires&quot;,&quot;0&quot;);</span></p><p style="color:#333333;font-family:Georgia, &quot;font-size:14px;background-color:#FFFFFF;"><span style="font-family: 宋体,SimSun; font-size: 14px;">
	&nbsp;</span></p><p style="color:#333333;font-family:Georgia, &quot;font-size:14px;background-color:#FFFFFF;"><span style="line-height: 1.8; color: #000000; font-family: 宋体,SimSun;"><strong>五、利用telnet观察http协议的通讯过程</strong></span></p><p style="color:#333333;font-family:Georgia, &quot;font-size:14px;background-color:#FFFFFF;"><span style="line-height: 1.8; color: #000000; font-family: 宋体,SimSun;">&nbsp;&nbsp;&nbsp;<span style="line-height: 1.8; color: #000000; font-family: 宋体,SimSun; font-size: 14px;"> 实验目的及原理：<br/>&nbsp;&nbsp;&nbsp; 利用MS的telnet工具，通过手动输入http请求信息的方式，向服务器发出请求，服务器接收、解释和接受请求后，会返回一个响应，该响应会在telnet窗口上显示出来，从而从感性上加深对http协议的通讯过程的认识。</span></span></p><p style="color:#333333;font-family:Georgia, &quot;font-size:14px;background-color:#FFFFFF;"><span style="line-height: 1.8; color: #000000; font-family: 宋体,SimSun; font-size: 14px;">&nbsp;&nbsp;&nbsp; 实验步骤：</span></p><p style="color:#333333;font-family:Georgia, &quot;font-size:14px;background-color:#FFFFFF;"><span style="line-height: 1.8; color: #000000; font-family: 宋体,SimSun; font-size: 14px;">1、打开telnet<br/>1.1 打开telnet<br/>运行--&gt;cmd--&gt;telnet</span></p><p style="color:#333333;font-family:Georgia, &quot;font-size:14px;background-color:#FFFFFF;"><span style="line-height: 1.8; color: #000000; font-family: 宋体,SimSun; font-size: 14px;">1.2 打开telnet回显功能<br/>set localecho</span></p><p style="color:#333333;font-family:Georgia, &quot;font-size:14px;background-color:#FFFFFF;"><span style="line-height: 1.8; color: #000000; font-family: 宋体,SimSun; font-size: 14px;">2、连接服务器并发送请求<br/>2.1 open&nbsp;</span><span style="line-height: 1.8; color: #000000; font-family: 宋体,SimSun; font-size: 14px;">www.guet.edu.cn</span><span style="line-height: 1.8; color: #000000; font-family: 宋体,SimSun; font-size: 14px;">&nbsp;80&nbsp; //注意端口号不能省略</span></p><p style="color:#333333;font-family:Georgia, &quot;font-size:14px;background-color:#FFFFFF;"><span style="line-height: 1.8; color: #000000; font-family: 宋体,SimSun; font-size: 14px;">&nbsp;&nbsp;&nbsp; HEAD /index.asp HTTP/1.0<br/>&nbsp;&nbsp;&nbsp; Host:www.guet.edu.cn<br/>&nbsp;&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp; /*我们可以变换请求方法,请求桂林电子主页内容,输入消息如下*/<br/>&nbsp;&nbsp;&nbsp; open&nbsp;</span><span style="line-height: 1.8; color: #000000; font-family: 宋体,SimSun; font-size: 14px;">www.guet.edu.cn</span><span style="line-height: 1.8; color: #000000; font-family: 宋体,SimSun; font-size: 14px;">&nbsp;80&nbsp;<br/>&nbsp;&nbsp;&nbsp;<br/>&nbsp;&nbsp;&nbsp; GET /index.asp HTTP/1.0&nbsp; //请求资源的内容<br/>&nbsp;&nbsp;&nbsp; Host:www.guet.edu.cn&nbsp;&nbsp;</span></p><p style="color:#333333;font-family:Georgia, &quot;font-size:14px;background-color:#FFFFFF;"><span style="line-height: 1.8; color: #000000; font-family: 宋体,SimSun; font-size: 14px;">2.2 open&nbsp;</span><span style="line-height: 1.8; color: #000000; font-family: 宋体,SimSun; font-size: 14px;">www.sina.com.cn</span><span style="line-height: 1.8; color: #000000; font-family: 宋体,SimSun; font-size: 14px;">&nbsp;80&nbsp; //在命令提示符号下直接输入telnet&nbsp;</span><span style="line-height: 1.8; color: #000000; font-family: 宋体,SimSun; font-size: 14px;">www.sina.com.cn</span><span style="line-height: 1.8; color: #000000; font-family: 宋体,SimSun; font-size: 14px;">&nbsp;80<br/>&nbsp;&nbsp;&nbsp; HEAD /index.asp HTTP/1.0<br/>&nbsp;&nbsp;&nbsp; Host:www.sina.com.cn<br/>&nbsp;</span></p><p style="color:#333333;font-family:Georgia, &quot;font-size:14px;background-color:#FFFFFF;"><span style="line-height: 1.8; color: #000000; font-family: 宋体,SimSun; font-size: 14px;">3 实验结果：</span></p><p style="color:#333333;font-family:Georgia, &quot;font-size:14px;background-color:#FFFFFF;"><span style="line-height: 1.8; color: #000000; font-family: 宋体,SimSun; font-size: 14px;">3.1 请求信息2.1得到的响应是:</span></p><p style="color:#333333;font-family:Georgia, &quot;font-size:14px;background-color:#FFFFFF;"><span style="line-height: 1.8; color: #000000; font-family: 宋体,SimSun; font-size: 14px;">HTTP/1.1 200 OK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //请求成功<br/>Server: Microsoft-IIS/5.0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //web服务器<br/>Date: Thu,08 Mar 200707:17:51 GMT<br/>Connection: Keep-Alive&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>Content-Length: 23330<br/>Content-Type: text/html<br/>Expries: Thu,08 Mar 2007 07:16:51 GMT<br/>Set-Cookie: ASPSESSIONIDQAQBQQQB=BEJCDGKADEDJKLKKAJEOIMMH; path=/<br/>Cache-control: private</span></p><p style="color:#333333;font-family:Georgia, &quot;font-size:14px;background-color:#FFFFFF;"><span style="line-height: 1.8; color: #000000; font-family: 宋体,SimSun; font-size: 14px;">//资源内容省略</span></p><p style="color:#333333;font-family:Georgia, &quot;font-size:14px;background-color:#FFFFFF;"><span style="line-height: 1.8; color: #000000; font-family: 宋体,SimSun; font-size: 14px;">3.2 请求信息2.2得到的响应是:</span></p><p style="color:#333333;font-family:Georgia, &quot;font-size:14px;background-color:#FFFFFF;"><span style="line-height: 1.8; color: #000000; font-family: 宋体,SimSun; font-size: 14px;">HTTP/1.0 404 Not Found&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //请求失败<br/>Date: Thu, 08 Mar 2007 07:50:50 GMT<br/>Server: Apache/2.0.54 &lt;Unix&gt;<br/>Last-Modified: Thu, 30 Nov 2006 11:35:41 GMT<br/>ETag: &quot;6277a-415-e7c76980&quot;<br/>Accept-Ranges: bytes<br/>X-Powered-By: mod_xlayout_jh/0.0.1vhs.markII.remix<br/>Vary: Accept-Encoding<br/>Content-Type: text/html<br/>X-Cache: MISS from zjm152-78.sina.com.cn<br/>Via: 1.0 zjm152-78.sina.com.cn:80&lt;squid/2.6.STABLES-20061207&gt;<br/>X-Cache: MISS from th-143.sina.com.cn<br/>Connection: close</span></p><p style="color:#333333;font-family:Georgia, &quot;font-size:14px;background-color:#FFFFFF;"><br/><span style="line-height: 1.8; color: #000000; font-family: 宋体,SimSun; font-size: 14px;">失去了跟主机的连接</span></p><p style="color:#333333;font-family:Georgia, &quot;font-size:14px;background-color:#FFFFFF;"><span style="line-height: 1.8; color: #000000; font-family: 宋体,SimSun; font-size: 14px;">按任意键继续...</span></p><p style="color:#333333;font-family:Georgia, &quot;font-size:14px;background-color:#FFFFFF;"><span style="line-height: 1.8; color: #000000; font-family: 宋体,SimSun; font-size: 14px;">4 .注意事项：</span></p><p style="color:#333333;font-family:Georgia, &quot;font-size:14px;background-color:#FFFFFF;"><span style="line-height: 1.8; color: #000000; font-family: 宋体,SimSun; font-size: 14px;">&nbsp; 1、出现输入错误，则请求不会成功。<br/>&nbsp; 2、报头域不分大小写。<br/>&nbsp; 3、更深一步了解HTTP协议，可以查看RFC2616，在</span><span style="line-height: 1.8; color: #000000; font-family: 宋体,SimSun; font-size: 14px;">http://www.letf.org/rfc</span><span style="line-height: 1.8; color: #000000; font-family: 宋体,SimSun; font-size: 14px;">上找到该文件。<br/>&nbsp; 4、开发后台程序必须掌握http协议</span></p><p style="color:#333333;font-family:Georgia, &quot;font-size:14px;background-color:#FFFFFF;"><span style="font-family: 宋体,SimSun;"><strong><span style="font-family: 宋体,SimSun; line-height: 1.8; color: #000000;">六、</span></strong><strong><span style="font-family: 宋体,SimSun; line-height: 1.8; color: #000000;"></span></strong></span><span style="line-height: 1.8; color: #000000; font-family: 宋体,SimSun;"><strong>HTTP协议相关技术补充</strong></span></p><p style="color:#333333;font-family:Georgia, &quot;font-size:14px;background-color:#FFFFFF;"><span style="line-height: 1.8; color: #000000; font-family: 宋体,SimSun;">&nbsp;&nbsp;&nbsp;<span style="line-height: 1.8; color: #000000; font-family: 宋体,SimSun; font-size: 14px;"> 1、基础：<br/>&nbsp;&nbsp;&nbsp; 高层协议有：文件传输协议FTP、电子邮件传输协议SMTP、域名系统服务DNS、网络新闻传输协议NNTP和HTTP协议等<br/>中介由三种：代理(Proxy)、网关(Gateway)和通道(Tunnel)，一个代理根据URI的绝对格式来接受请求，重写全部或部分消息，通过 URI的标识把已格式化过的请求发送到服务器。网关是一个接收代理，作为一些其它服务器的上层，并且如果必须的话，可以把请求翻译给下层的服务器协议。一 个通道作为不改变消息的两个连接之间的中继点。当通讯需要通过一个中介(例如：防火墙等)或者是中介不能识别消息的内容时，通道经常被使用。<br/>&nbsp;&nbsp; 代理(Proxy)：一个中间程序，它可以充当一个服务器，也可以充当一个客户机，为其它客户机建立请求。请求是通过可能的翻译在内部或经过传递到其它的 服务器中。一个代理在发送请求信息之前，必须解释并且如果可能重写它。代理经常作为通过防火墙的客户机端的门户，代理还可以作为一个帮助应用来通过协议处 理没有被用户代理完成的请求。<br/>网关(Gateway)：一个作为其它服务器中间媒介的服务器。与代理不同的是，网关接受请求就好象对被请求的资源来说它就是源服务器；发出请求的客户机并没有意识到它在同网关打交道。<br/>网关经常作为通过防火墙的服务器端的门户，网关还可以作为一个协议翻译器以便存取那些存储在非HTTP系统中的资源。<br/>&nbsp;&nbsp;&nbsp; 通道(Tunnel)：是作为两个连接中继的中介程序。一旦激活，通道便被认为不属于HTTP通讯，尽管通道可能是被一个HTTP请求初始化的。当被中继 的连接两端关闭时，通道便消失。当一个门户(Portal)必须存在或中介(Intermediary)不能解释中继的通讯时通道被经常使用。<br/>2、协议分析的优势—HTTP分析器检测网络攻击<br/>以模块化的方式对高层协议进行分析处理，将是未来入侵检测的方向。<br/>HTTP及其代理的常用端口80、3128和8080在network部分用port标签进行了规定<br/>3、HTTP协议Content Lenth限制漏洞导致拒绝服务攻击<br/>使用POST方法时，可以设置ContentLenth来定义需要传送的数据长度，例如ContentLenth:999999999，在传送完成前，内 存不会释放，攻击者可以利用这个缺陷，连续向WEB服务器发送垃圾数据直至WEB服务器内存耗尽。这种攻击方法基本不会留下痕迹。<br/>http://www.cnpaf.net/Class/HTTP/0532918532667330.html<br/>4、利用HTTP协议的特性进行拒绝服务攻击的一些构思<br/>服务器端忙于处理攻击者伪造的TCP连接请求而无暇理睬客户的正常请求（毕竟客户端的正常请求比率非常之小），此时从正常客户的角度看来，服务器失去响应，这种情况我们称作：服务器端受到了SYNFlood攻击（SYN洪水攻击）。<br/>而Smurf、TearDrop等是利用ICMP报文来Flood和IP碎片攻击的。本文用“正常连接”的方法来产生拒绝服务攻击。<br/>19端口在早期已经有人用来做Chargen攻击了，即Chargen_Denial_of_Service，但是！他们用的方法是在两台Chargen 服务器之间产生UDP连接，让服务器处理过多信息而DOWN掉，那么，干掉一台WEB服务器的条件就必须有2个：1.有Chargen服务2.有HTTP 服务<br/>方法：攻击者伪造源IP给N台Chargen发送连接请求（Connect），Chargen接收到连接后就会返回每秒72字节的字符流（实际上根据网络实际情况，这个速度更快）给服务器。<br/><br/>5、Http指纹识别技术<br/>&nbsp;&nbsp; Http指纹识别的原理大致上也是相同的：记录不同服务器对Http协议执行中的微小差别进行识别.Http指纹识别比TCP/IP堆栈指纹识别复杂许 多,理由是定制Http服务器的配置文件、增加插件或组件使得更改Http的响应信息变的很容易,这样使得识别变的困难；然而定制TCP/IP堆栈的行为 需要对核心层进行修改,所以就容易识别.<br/>&nbsp;&nbsp; 要让服务器返回不同的Banner信息的设置是很简单的,象Apache这样的开放源代码的Http服务器,用户可以在源代码里修改Banner信息,然 后重起Http服务就生效了；对于没有公</span><a style="font-size: 14px; text-decoration: underline;" href="http://www.php1.cn/category/121.html"><span style="line-height: 1.8; color: #000000; font-family: 宋体,SimSun; font-size: 14px;">开源</span></a><span style="line-height: 1.8; color: #000000; font-family: 宋体,SimSun; font-size: 14px;">代码的Http服务器比如微软的IIS或者是Netscape,可以在存放Banner信息的Dll文件中修 改,相关的文章有讨论的,这里不再赘述,当然这样的修改的效果还是不错的.另外一种模糊Banner信息的方法是使用插件。<br/>常用测试请求：<br/>1：HEAD/Http/1.0发送基本的Http请求<br/>2：DELETE/Http/1.0发送那些不被允许的请求,比如Delete请求<br/>3：GET/Http/3.0发送一个非法版本的Http协议请求<br/>4：GET/JUNK/1.0发送一个不正确规格的Http协议请求<br/>Http指纹识别工具Httprint,它通过运用统计学原理,组合模糊的逻辑学技术,能很有效的确定Http服务器的类型.它可以被用来收集和分析不同Http服务器产生的签名。<br/>6、其他：为了提高用户使用浏览器时的性能，现代浏览器还支持并发的访问方式，浏览一个网页时同时建立多个连接，以迅速获得一个网页上的多个图标，这样能更快速完成整个网页的传输。<br/>HTTP1.1中提供了这种持续连接的方式，而下一代HTTP协议：HTTP-NG更增加了有关会话控制、丰富的内容协商等方式的支持，来提供<br/>更高效率的连接。</span></span></p><p><span style="font-family: 宋体,SimSun;">&nbsp;</span></p>";s:7:"picture";s:0:"";s:11:"createdtime";s:10:"1497541259";s:8:"category";s:9:"1000,1111";s:7:"chapter";s:14:"2000,2001,2011";s:8:"nickname";s:5:"gw123";s:6:"avatar";s:26:"/images/default/avatar.png";s:8:"desc_len";s:1:"0";s:8:"body_len";s:4:"9102";s:10:"status_len";s:1:"1";s:11:"createdTime";s:10:"1497541259";s:6:"userId";s:1:"1";}i:7;a:20:{s:2:"id";s:3:"248";s:2:"pv";s:2:"17";s:10:"collectnum";s:1:"0";s:5:"title";s:23:"H5视频直播那些事";s:6:"userid";s:1:"1";s:8:"promoted";s:1:"1";s:10:"categoryid";s:1:"0";s:4:"desc";s:0:"";s:4:"body";s:18664:"<p><strong>分享内容简介：</strong>目前视频直播，尤其是移动端的视频直播已经火到不行了，基本上各大互联网公司都有了自己的直播产品，所以对于直播的一些基本知识和主要技术点也要有所了解，本次分享就向大家介绍一下其中的奥秘。</p><p><strong>内容大体框架:</strong></p><ol class=" list-paddingleft-2"><li><p>怎样利用H5来播放直播视频</p></li><li><p>怎样录制直播视频</p></li><li><p>怎样实时上传直播视频</p></li><li><p>直播中的用户交互</p></li></ol><p><strong>分享人介绍：</strong></p><p><strong>吕鸣</strong> 目前在腾讯SNG担任手Q的web前端开发工作
博客：<a href="http://www.nihaoshijie.com.cn/" target="_blank">http://www.nihaoshijie.com.cn/</a></p><hr/><p><strong>下面是本期分享内容整理</strong></p><hr/><p>Hello, 大家好，我是吕鸣，目前是在腾讯 SNG 的即通应用部负责手Q的兴趣部落 Web 前端开发工作。</p><p>针对目前比较火的视频直播，我做了一些研究和探索，同时我们的项目将会用到直播为此打下技术基础，下面就向大家分享一下直播的整个流程和一些技术点。</p><h2>一、移动视频直播发展</h2><p>大家首先来看下面这张图:</p><p><img src="http://oa5504rxk.bkt.clouddn.com/dev_Club_07/1.jpg" alt=""/></p><p>可以看到，直播从 PC 到一直发展到移动端，越来越多的直播类 App 上线，同时移动直播进入了前所未有的爆发阶段，但是对于大多数移动直播来说，还是要以 Native 客户端实现为主，但是 H5 在移动直播端也承载着不可替代的作用，例如 H5 有着<strong>传播快，易发布</strong>的优势，同时最为关键的时 H5 同样可以播放直播视频。</p><p>大家可以看下面这张大概的实现图</p><p><img src="http://oa5504rxk.bkt.clouddn.com/dev_Club_07/2.jpg" alt=""/></p><p><strong>完整的直播可以分为以下几块：</strong></p><ol class=" list-paddingleft-2"><li><p><strong>视频录制端</strong>：一般是电脑上的音视频输入设备或者手机端的摄像头或者麦克风，目前以移动端的手机视频为主。</p></li><li><p><strong>视频播放端</strong>：可以是电脑上的播放器，手机端的 Native 播放器，还有就是 H5 的 <code>video</code> 标签等，目前还是已手机端的 Native 播放器为主。</p></li><li><p><strong>视频服务器端</strong>：一般是一台 nginx 服务器，用来接受视频录制端提供的视频源，同时提供给视频播放端流服务。</p></li></ol><p>大家可以看下大致的结构图：</p><p><img src="http://oa5504rxk.bkt.clouddn.com/dev_Club_07/3.jpg" alt=""/></p><h2>二、H5 录制视频：</h2><p>对于H5视频录制，可以使用强大的 <strong>webRTC</strong> （Web Real-Time Communication）是一个支持网页浏览器进行实时语音对话或视频对话的技术，缺点是只在 PC 的 Chrome 上支持较好，移动端支持不太理想。</p><p><strong>使用 webRTC 录制视频基本流程是：</strong></p><ol class=" list-paddingleft-2"><li><p>调用 <code>window.navigator.webkitGetUserMedia()</code> 获取用户的PC摄像头视频数据。</p></li><li><p>将获取到视频流数据转换成 <code>window.webkitRTCPeerConnection</code> (一种视频流数据格式)。</p></li><li><p>利用 webscoket 将视频流数据传输到服务端</p></li></ol><p>由于许多方法都要加上浏览器前缀，所以很多移动端的浏览器还不支持 webRTC，所以真正的视频录制还是要靠客户端（iOS,Android）来实现,效果会好一些。</p><h2>三、H5 播放直播视频：</h2><p>对于视频播放，可以使用 HLS(HTTP Live Streaming)协议播放直播流，iOS和 Android 都天然支持这种协议，配置简单，直接使用 <code>video</code> 标签即可。</p><p>下面是简单的代码使用 <code>video</code> 播放直播视频：</p><p><img src="http://oa5504rxk.bkt.clouddn.com/dev_Club_07/4.jpg" alt=""/></p><h3>1.什么是 HLS 协议:</h3><p>简单讲就是把整个流分成一个个小的，基于 HTTP 的文件来下载，每次只下载一些，前面提到了用于 H5 播放直播视频时引入的一个 .m3u8 的文件，这个文件就是基于 HLS 协议，存放视频流元数据的文件。</p><p>每一个 .m3u8 文件，分别对应若干个 ts 文件，这些 ts 文件才是真正存放视频的数据，m3u8 文件只是存放了一些 ts 文件的配置信息和相关路径，当视频播放时，.m3u8 是动态改变的，<code>video</code> 标签会解析这个文件，并找到对应的 ts 文件来播放，所以一般为了加快速度，.m3u8 放在 Web 服务器上，ts 文件放在 CDN 上。</p><p>.m3u8 文件，其实就是以 UTF-8 编码的 m3u 文件，这个文件本身不能播放，只是存放了播放信息的文本文件。</p><p>打开之后就是这个样子：</p><p><img src="http://oa5504rxk.bkt.clouddn.com/dev_Club_07/5.jpg" alt=""/></p><p>下面这个是 ts 文件，就是存放视频的文件：</p><p><img src="http://oa5504rxk.bkt.clouddn.com/dev_Club_07/6.jpg" alt=""/></p><h3>2.HLS 的请求流程：</h3><ol class=" list-paddingleft-2"><li><p>HTTP 请求 m3u8 的 url。</p></li><li><p>服务端返回一个 m3u8 的播放列表，这个播放列表是实时更新的，一般一次给出5段数据的 url。</p></li><li><p>客户端解析 m3u8 的播放列表，再按序请求每一段的 url，获取 ts 数据流。</p></li></ol><p>大概是这个流程：</p><p><img src="http://oa5504rxk.bkt.clouddn.com/dev_Club_07/7.jpg" alt=""/></p><h3>3.HLS 直播延时:</h3><p>我们知道 hls 协议是将直播流分成一段一段的小段视频去下载播放的，所以假设列表里面的包含5个 ts 文件，每个 TS 文件包含5秒的视频内容，那么整体的延迟就是25秒。因为当你看到这些视频时，主播已经将视频录制好上传上去了，所以时这样产生的延迟。当然可以缩短列表的长度和单个 ts 文件的大小来降低延迟，极致来说可以缩减列表长度为1，并且 ts 的时长为1s，但是这样会造成请求次数增加，增大服务器压力，当网速慢时回造成更多的缓冲，所以苹果官方推荐的 ts 时长时10s，所以这样就会大改有30s的延迟。所以服务器接收流，转码，保存，切块，再分发给客户端，这里就延时的根本原因。</p><p>更多关于延迟的问题可以参考苹果官方地址：<a href="https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/StreamingMediaGuide/FrequentlyAskedQuestions/FrequentlyAskedQuestions.html" target="_blank">https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/StreamingMediaGuide/FrequentlyAskedQuestions/FrequentlyAskedQuestions.html</a></p><p><strong>但是 H5 直播视频却有一些不可替代的优势:</strong></p><ol class=" list-paddingleft-2"><li><p>传播性好，利于分享等操作。</p></li><li><p>可以动态发布，有利于实时迭代产品需求并迅速上线。</p></li><li><p>不用安装 App，直接打开浏览器即可。</p></li></ol><h2>四、iOS 采集（录制）音视频数据OS</h2><p>关于音视频采集录制，首先明确下面几个概念：</p><ul class=" list-paddingleft-2"><li><p><strong>视频编码</strong>：所谓视频编码就是指通过特定的压缩技术，将某个视频格式的文件转换成另一种视频格式文件的方式，我们使用的 iPhone 录制的视频，必须要经过编码，上传，解码，才能真正的在用户端的播放器里播放。</p></li><li><p><strong>编解码标准</strong>：视频流传输中最为重要的编解码标准有国际电联的 H.261、H.263、H.264，其中 HLS 协议支持 H.264 格式的编码。</p></li><li><p><strong>音频编码</strong>：同视频编码类似，将原始的音频流按照一定的标准进行编码，上传，解码，同时在播放器里播放，当然音频也有许多编码标准，例如 PCM 编码，WMA 编码，AAC 编码等等，这里我们 HLS 协议支持的音频编码方式是 AAC 编码。</p></li></ul><p>利用 iOS 上的摄像头，进行音视频的数据采集，主要分为以下几个步骤：</p><ol class=" list-paddingleft-2"><li><p>音视频的采集，iOS 中，利用 AVCaptureSession 和 AVCaptureDevice 可以采集到原始的音视频数据流。</p></li><li><p>对视频进行 H264 编码，对音频进行 AAC 编码，在 iOS 中分别有已经封装好的编码库来实现对音视频的编码。</p></li><li><p>对编码后的音、视频数据进行组装封包；</p></li><li><p>建立 RTMP 连接并上推到服务端。</p></li></ol><p>下面是具体的采集音视频数据的流程：</p><p><img src="http://oa5504rxk.bkt.clouddn.com/dev_Club_07/8.jpg" alt=""/></p><h3>1.关于 RTMP：</h3><p>Real Time Messaging Protocol（简称 RTMP）是 Macromedia 开发的一套视频直播协议，现在属于 Adobe。和 HLS 一样都可以应用于视频直播，区别是 RTMP 基于 flash 无法在 iOS 的浏览器里播放，但是实时性比 HLS 要好。所以一般使用这种协议来上传视频流，也就是视频流推送到服务器。</p><p>下面是 HLS 和 RTMP 的对比：</p><p><img src="http://oa5504rxk.bkt.clouddn.com/dev_Club_07/9.jpg" alt=""/></p><h3>2.推流</h3><p>所谓推流，就是将我们已经编码好的音视频数据发往视频流服务器中，在 iOS 代码里面一般常用的是使用 RTMP 推流，可以使用第三方库 librtmp-iOS 进行推流，librtmp 封装了一些核心的 API 供使用者调用。例如推流 API 等等，配置服务器地址，即可将转码后的视频流推往服务器。</p><p><strong>那么如何搭建一个推流服务器呢？</strong></p><p>简单的推流服务器搭建，由于我们上传的视频流都是基于 RTMP 协议的，所以服务器也必须要支持 RTMP 才行，大概需要以下几个步骤：</p><ol class=" list-paddingleft-2"><li><p>安装一台 nginx 服务器。</p></li><li><p>安装 nginx 的 RTMP 扩展，目前使用比较多的是 <a href="https://github.com/arut/nginx-rtmp-module" target="_blank">https://github.com/arut/nginx-rtmp-module</a></p></li><li><p>配置 nginx 的 conf 文件</p></li><li><p>重启 nginx，将 RTMP 的推流地址写为 rtmp://ip:1935/hls/mystream， 其中 hls_path 
表示生成的 .m3u8 和 ts 文件所存放的地址，hls_fragment 表示切片时长，mysteam 
表示一个实例，即将来要生成的文件名可以先自己随便设置一个。</p></li></ol><p>更多配置可以参考：<a href="https://github.com/arut/nginx-rtmp-module/wiki/" target="_blank">https://github.com/arut/nginx-rtmp-module/wiki/</a></p><p>下面是 nginx 的配置文件</p><p><img src="http://oa5504rxk.bkt.clouddn.com/dev_Club_07/10.jpg" alt=""/></p><h2>五、直播中的用户交互：</h2><p>对于直播中的用户交互大致可以分为：</p><ol class=" list-paddingleft-2"><li><p>送礼物</p></li><li><p>发表评论或者弹幕</p></li></ol><p>对于送礼物，在 H5 端可以利用 DOM 和 CSS3 实现送礼物逻辑和一些特殊的礼物动画，实现技术难点不大。</p><p>对于弹幕来说，要稍微复杂一些，可能需要关注以下几点：</p><ol class=" list-paddingleft-2"><li><p>弹幕实时性，可以利用 webscoket 来实时发送和接收新的弹幕并渲染出来。</p></li><li><p>对于不支持 webscoket 的浏览器来说，只能降级为长轮询或者前端定时器发送请求来获取实时弹幕。</p></li><li><p>弹幕渲染时的动画和碰撞检测(即弹幕不重叠)等等</p></li></ol><h2>六、总结</h2><p>目前较为成熟的直播产品，大致都是以 Server 端和 H5 和 Native(android,ios)搭配实现直播：</p><p>基本是下图这个套路：</p><p><img src="http://oa5504rxk.bkt.clouddn.com/dev_Club_07/11.jpg" alt=""/></p><p><strong>所以 H5 在整个直播中，还是有着重要的地位的！</strong></p><h2>Demo 分享</h2><p>最后，根据本次分享的内容，我这边实现了一个 iOS 端录制，推流，NGINX 接收流，同时分发的 HLS 直播流的一整套 Demo，感兴趣的同学可以看下面这个链接:</p><p><a href="https://github.com/lvming6816077/LMVideoTest" target="_blank">https://github.com/lvming6816077/LMVideoTest</a></p><p>好了，本次分享先到这里了，谢谢大家~</p><h2>互动问答环节</h2><p><strong>Q1</strong>: Demo 包含 iOS 端的 RTMP 播放不？</p><blockquote><p>答：Demo 里面没有 RTMP 的播放，Demo 主要是提供录制，推流的。</p></blockquote><p><strong>Q2</strong>: 对于 H5 &nbsp;HLS 播放 卡顿问题，前端与 server 端，有什么配置上的优化吗？</p><blockquote><p>答：server 端要做好分片策略，同时要将 ts 文件放在 CDN 上，前端这边可以尽量做到 DNS 缓存等，由于H5是使用的 video 标签，所以要修改 video 的播放优化，还是不那么容易。</p></blockquote><p><strong>Q3</strong>: 在手机推流时的码率是根据怎样的策略做选择的？不同机型和网络下如何保持流畅？</p><blockquote><p>答：可以提供不同的视频码率来供用户选择，例如网速差的可以选择较为低清晰度的码率，网络好的用户可以选择更加清晰的码率，同时做好视频播放端的容错和异常处理等等。</p></blockquote><p><strong>Q4</strong>: RTMP 比起 HTTP 他的优势主要是几种在哪里？</p><blockquote><p>答：RTMP 是基于 TCP 的保持的是长连接，而 HTTP 是一次性的，每次都要三次握手，所以对于直播来说还是 RTMP 好一些</p></blockquote><p><strong>Q5</strong>: 据我所知 nginx rtmp-module 好像性能不是很高…为什么会采用这个来作为后端服务？</p><blockquote><p>答：这里只是 Demo 用了这个 nginx rtmp-module，其实也可已选择 SRS(simple-rtmp-server)都是可以的哈</p></blockquote><p><strong>Q6</strong>: 移动端这边怎么进行编码转码？用 ffmpeg 编译时很麻烦</p><blockquote><p>答：关于 iOS 这边，其实不用关心转码问题，因为已经有了很多开源的库提供给我们了例如：
x264 编码：<a href="https://github.com/kewlbear/x264-ios" target="_blank">https://github.com/kewlbear/x264-ios</a>faac 编码：<a href="https://github.com/fflydev/faac-ios-build" target="_blank">https://github.com/fflydev/faac-ios-build</a></p></blockquote><p><strong>Q7</strong>: 您介绍的都是 Native 播放和还有 H5 的 video 标签播放, iOS 端有没有考虑过整个用原生的 OC 或者 Swift 实现?</p><blockquote><p>答：关于播放端，其实真正体验好的还是要用 native 来实现的，而且 native 实现可以用 RTMP 来播放直播，延迟会好很多，H5 来播直播主要是考虑到易传播性好。</p></blockquote><p><strong>Q8</strong>: 在用户非常多的情况下，或者网络慢的情况下，有什么策略可以保证质量？</p><blockquote><p>答：可以提供不同的视频码率来供用户选择，例如网速差的可以选择较为低清晰度的码率，网络好的用户可以选择更加清晰的码率，同时做好视频播放端的容错和异常处理等等。</p></blockquote><p><strong>Q9</strong>: 请问直播这块的测试中关注的几个指标是什么，有什么比较好的测试方法呢？</p><blockquote><p>答：主要就是：</p><ol class=" list-paddingleft-2"><li><p>首次打开的白屏时间</p></li><li><p>直播中的卡顿和缓冲</p></li><li><p>直播的延时</p></li></ol></blockquote><p><strong>Q10</strong>: 您提供的 Demo 为什么不是 H5 的呢 iOS 推流和 nginx 服务器都有，能不能提供一个前面第二张叶子美女直播那个页面的 Demo？</p><blockquote><p>答：这个 Demo 你下载下拉运行的话，根据配置就可直接自己实现一个利用 H5 直播的页面，很简单，就像使用 video 标签一样，其他的样式你可以自己定制的。</p></blockquote><p><strong>Q11</strong>: HLS 的延时有没有比较好的方法解决？</p><blockquote><p>答：HLS 确实是会有延迟，相对比较优的策略是调整好分片策略，在保证性能的情况下，和延迟达到平衡。</p></blockquote><p><strong>Q12</strong>: 如果加入视频电话功能，上面的结构需要作什么改变？视频电话的目的大概是：直播可以选择某一观众或者多个观众视频对话</p><blockquote><p>答：视频电话，也就是说作为视频录制端的同时也作为视频播放端，所以实现实时电话简单就是：我在直播的同时观看别人的直播视频，别人在直播的同时观看我的直播视频，可以这样理解，上面的结构复制一份对调即可。</p></blockquote><p><strong>Q13</strong>: 如何实现滤镜功能？</p><blockquote><p>答：一般是在视频录制之后，在转码前给视频数据增加滤镜功能，在 iOS 里可以使用一些滤镜库等等实现滤镜功能</p></blockquote><p><strong>Q14</strong>: 在 App 端如果不利用 H5 能实现直播吗？</p><blockquote><p>答：可以啊，app 有更加丰富的播放接口，和开源播放器可以实现直播的。</p></blockquote><p><strong>Q15</strong>: 既然 HLS 有较高的延迟 为什么苹果推荐的的方式却是 HLS？</p><blockquote><p>答：并不是说苹果主要推荐使用 HLS，对于 H5 来说目前只有这一种比较好的方式来播放直播视频，所以还是很期待苹果能对延迟问题做一些改进的。</p></blockquote><p><strong>Q16</strong>: 同滤镜问题，音频变声是如何实现的？</p><blockquote><p>答：同样是可以在对音频转码前操作。</p></blockquote><p><strong>Q17</strong>: 如果针对网络较差的观看用户，是需要直播推流到服务器后做多份不同分辨率的拷贝，以适应不同网络的用户观看？如果是这样的话，对延迟会不会影响很大？ 毕竟编解码也是需要时间的.</p><blockquote><p>答：这个其实本身就应该做的，对于网络差的用户，完全可以提供给他们较低码率的直播流来减少卡顿问题，延迟问题的话还是要根据具体使用哪种协议来定。</p></blockquote><p><strong>Q18</strong>: 推流目前大部分都是第三方在做，难度点在哪？然后目前业内比较成熟的主要哪些？</p><blockquote><p>答：难点主要是服务器端的性能压力和分发直播流的效率，业界都已经有了较成熟的方案，例如腾讯云的直播。</p></blockquote>";s:7:"picture";s:0:"";s:11:"createdtime";s:10:"1498384681";s:8:"category";s:9:"1000,1112";s:7:"chapter";s:14:"1600,1846,1847";s:8:"nickname";s:5:"gw123";s:6:"avatar";s:26:"/images/default/avatar.png";s:8:"desc_len";s:1:"0";s:8:"body_len";s:4:"5244";s:10:"status_len";s:1:"1";s:11:"createdTime";s:10:"1498384681";s:6:"userId";s:1:"1";}i:8;a:20:{s:2:"id";s:3:"253";s:2:"pv";s:2:"17";s:10:"collectnum";s:1:"0";s:5:"title";s:30:"PHP  实现WebScoket 服务端";s:6:"userid";s:1:"1";s:8:"promoted";s:2:"10";s:10:"categoryid";s:1:"0";s:4:"desc";s:0:"";s:4:"body";s:22150:"<pre class="brush:php;toolbar:false">&lt;?php

global&nbsp;$logContainer&nbsp;;&nbsp;$logContainer&nbsp;=&nbsp;[];

class&nbsp;WS&nbsp;{
&nbsp;&nbsp;var&nbsp;$master;
&nbsp;&nbsp;var&nbsp;$sockets&nbsp;=&nbsp;array();
&nbsp;&nbsp;var&nbsp;$debug&nbsp;=&nbsp;false;
&nbsp;&nbsp;var&nbsp;$handshake&nbsp;=&nbsp;false;

&nbsp;&nbsp;function&nbsp;__construct($address,&nbsp;$port){
&nbsp;&nbsp;&nbsp;&nbsp;$this-&gt;master=socket_create(AF_INET,&nbsp;SOCK_STREAM,&nbsp;SOL_TCP)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;or&nbsp;die(&quot;socket_create()&nbsp;failed&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;socket_set_option($this-&gt;master,&nbsp;SOL_SOCKET,&nbsp;SO_REUSEADDR,&nbsp;1)&nbsp;&nbsp;or&nbsp;die(&quot;socket_option()&nbsp;failed&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;socket_bind($this-&gt;master,&nbsp;$address,&nbsp;$port)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;or&nbsp;die(&quot;socket_bind()&nbsp;failed&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;socket_listen($this-&gt;master,20)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;or&nbsp;die(&quot;socket_listen()&nbsp;failed&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;$this-&gt;sockets[]&nbsp;=&nbsp;$this-&gt;master;
&nbsp;&nbsp;&nbsp;&nbsp;$this-&gt;say(&quot;Server&nbsp;Started&nbsp;:&nbsp;&quot;.date(&#39;Y-m-d&nbsp;H:i:s&#39;));
&nbsp;&nbsp;&nbsp;&nbsp;$this-&gt;say(&quot;Listening&nbsp;on&nbsp;&nbsp;&nbsp;:&nbsp;&quot;.$address.&quot;&nbsp;port&nbsp;&quot;.$port);
&nbsp;&nbsp;&nbsp;&nbsp;$this-&gt;say(&quot;Master&nbsp;socket&nbsp;&nbsp;:&nbsp;&quot;.$this-&gt;master.&quot;\n&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;while(true){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$socketArr&nbsp;=&nbsp;$this-&gt;sockets;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$write&nbsp;=&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$except&nbsp;=&nbsp;NULL;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;socket_select($socketArr,&nbsp;$write,&nbsp;$except,&nbsp;NULL);&nbsp;&nbsp;//自动选择来消息的socket&nbsp;如果是握手&nbsp;自动选择主机
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;($socketArr&nbsp;as&nbsp;$socket){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;($socket&nbsp;==&nbsp;$this-&gt;master){&nbsp;&nbsp;//主机
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$client&nbsp;=&nbsp;socket_accept($this-&gt;master);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;($client&nbsp;&lt;&nbsp;0){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$this-&gt;log(&quot;socket_accept()&nbsp;failed&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$this-&gt;connect($client);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$this-&gt;log(&quot;^^^^&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$bytes&nbsp;=&nbsp;@socket_recv($socket,$buffer,2048,0);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;($bytes&nbsp;===&nbsp;false){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$this-&gt;log(&nbsp;&quot;socket_recv()&nbsp;failed:&nbsp;&quot;&nbsp;.&nbsp;socket_last_error($socket)&nbsp;.&nbsp;&quot;\n&quot;&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$this-&gt;disConnect($socket);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;360&nbsp;浏览器在这里请求时会有一个bug,&nbsp;浏览器在刷新时不在发送握手数据&nbsp;但是却开了一个新的连接&nbsp;&nbsp;原有连接也没有关闭.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//判断是否为握手数据
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$header&nbsp;&nbsp;&nbsp;&nbsp;=&nbsp;$this-&gt;parseHandShake($buffer);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$postData&nbsp;=&nbsp;$this-&gt;parsePostRequest($buffer);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;($header){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$this-&gt;doHandShake($socket,&nbsp;$header);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;if($postData)&nbsp;&nbsp;//&nbsp;通过post传递过来的数据
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;//新的调试数据到来
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$this-&gt;doResponse($socket,&quot;ok&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$this-&gt;disConnect($socket);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;(&nbsp;$this-&gt;sockets&nbsp;as&nbsp;$index=&gt;$st)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if($index==0)&nbsp;continue;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$this-&gt;send($st,&nbsp;json_encode($postData)&nbsp;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}else{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$buffer&nbsp;=&nbsp;$this-&gt;decode($buffer);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;(&nbsp;$this-&gt;sockets&nbsp;as&nbsp;$index=&gt;$st)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if($index==0)&nbsp;continue;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$this-&gt;send($st,$buffer);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;}

&nbsp;&nbsp;//解析整数据&nbsp;判断是否为握手帧&nbsp;&nbsp;返回解析后的数据
&nbsp;&nbsp;function&nbsp;&nbsp;parseHandShake($buffer)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$headers&nbsp;=&nbsp;explode(&quot;\r\n&quot;&nbsp;,&nbsp;$buffer);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(empty($headers)||!is_array($headers))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;false;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$method&nbsp;=&nbsp;&nbsp;array_shift($headers);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(&nbsp;!&nbsp;strstr($method&nbsp;,&nbsp;&#39;GET&#39;)&nbsp;)&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//echo&nbsp;&quot;Not&nbsp;Get&nbsp;set&nbsp;::&nbsp;\n&quot;.$buffer;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;false;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(&nbsp;!(array_pop($headers)&nbsp;==&#39;&#39;&nbsp;&amp;&amp;&nbsp;array_pop($headers)==&#39;&#39;)&nbsp;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;&quot;header&nbsp;not&nbsp;end&nbsp;with&nbsp;tow&nbsp;&nbsp;enter&nbsp;\n&quot;;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;false;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$headerBuffer&nbsp;=&nbsp;[];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;($headers&nbsp;as&nbsp;$headerStr)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list($key&nbsp;,$value)&nbsp;=&nbsp;explode(&quot;:&nbsp;&quot;&nbsp;,$headerStr);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if($key&amp;&amp;$value)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$headerBuffer[$key]&nbsp;=&nbsp;$value;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//var_dump($headerBuffer);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(&nbsp;isset(&nbsp;$headerBuffer[&#39;Upgrade&#39;]&nbsp;)&nbsp;&amp;&amp;&nbsp;$headerBuffer[&#39;Upgrade&#39;]&nbsp;==&nbsp;&quot;websocket&quot;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;}&nbsp;else&nbsp;{&nbsp;return&nbsp;false;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(&nbsp;!isset(&nbsp;$headerBuffer[&#39;Sec-WebSocket-Key&#39;])&nbsp;)&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;false;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;$headerBuffer;
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;&nbsp;&nbsp;//解析整数据&nbsp;解析post数据
&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;&nbsp;parsePostRequest($buffer)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$headers&nbsp;=&nbsp;explode(&quot;\r\n&quot;&nbsp;,&nbsp;$buffer);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(empty($headers)||!is_array($headers))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;false;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$method&nbsp;=&nbsp;&nbsp;array_shift($headers);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(&nbsp;!&nbsp;strstr($method&nbsp;,&nbsp;&#39;POST&#39;)&nbsp;)&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//echo&nbsp;&quot;Not&nbsp;Get&nbsp;set&nbsp;::&nbsp;\n&quot;.$buffer;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;false;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$postField&nbsp;=&nbsp;array_pop($headers);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if($postField==&#39;&#39;)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&#39;&#39;;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$fieldArr&nbsp;=&nbsp;explode(&#39;&amp;&#39;,$postField);

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$postData&nbsp;=&nbsp;[];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;($fieldArr&nbsp;as&nbsp;$field)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list($key&nbsp;,$value)&nbsp;=&nbsp;explode(&quot;=&quot;&nbsp;,$field);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if($key&amp;&amp;$value)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$postData[$key]&nbsp;=&nbsp;urldecode($value);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//var_dump($postData);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;$postData;
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;function&nbsp;send($client,&nbsp;$msg){
&nbsp;&nbsp;&nbsp;&nbsp;$this-&gt;log(&quot;&gt;&nbsp;&quot;&nbsp;.&nbsp;$msg);
&nbsp;&nbsp;&nbsp;&nbsp;$msg&nbsp;=&nbsp;$this-&gt;encode($msg);
&nbsp;&nbsp;&nbsp;&nbsp;$len&nbsp;=&nbsp;@socket_write($client,&nbsp;$msg,&nbsp;strlen($msg));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if($len&nbsp;==&nbsp;false)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$this-&gt;disConnect($client);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;$this-&gt;log(&quot;!&nbsp;&quot;&nbsp;.&nbsp;strlen($msg));
&nbsp;&nbsp;}
&nbsp;&nbsp;function&nbsp;connect($socket){
&nbsp;&nbsp;&nbsp;&nbsp;array_push($this-&gt;sockets,&nbsp;$socket);
&nbsp;&nbsp;&nbsp;&nbsp;$this-&gt;say(&quot;\n&quot;&nbsp;.&nbsp;$socket&nbsp;.&nbsp;&quot;&nbsp;CONNECTED!&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;$this-&gt;say(date(&quot;Y-n-d&nbsp;H:i:s&quot;));
&nbsp;&nbsp;}
&nbsp;&nbsp;function&nbsp;disConnect($socket){
&nbsp;&nbsp;&nbsp;&nbsp;$index&nbsp;=&nbsp;array_search($socket,&nbsp;$this-&gt;sockets);
&nbsp;&nbsp;&nbsp;&nbsp;socket_close($socket);
&nbsp;&nbsp;&nbsp;&nbsp;$this-&gt;say($socket&nbsp;.&nbsp;&quot;&nbsp;DISCONNECTED!&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;($index&nbsp;&gt;=&nbsp;0){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;array_splice($this-&gt;sockets,&nbsp;$index,&nbsp;1);&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;}

&nbsp;&nbsp;//和浏览器握手
&nbsp;&nbsp;function&nbsp;doHandShake($socket,&nbsp;$header){
&nbsp;&nbsp;&nbsp;&nbsp;$this-&gt;log(&quot;\nRequesting&nbsp;handshake...&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$key&nbsp;=&nbsp;$header[&#39;Sec-WebSocket-Key&#39;];
&nbsp;&nbsp;&nbsp;&nbsp;$this-&gt;log(&quot;Handshaking...&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;$upgrade&nbsp;&nbsp;=&nbsp;&quot;HTTP/1.1&nbsp;101&nbsp;Switching&nbsp;Protocol\r\n&quot;&nbsp;.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;Upgrade:&nbsp;websocket\r\n&quot;&nbsp;.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;Connection:&nbsp;Upgrade\r\n&quot;&nbsp;.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;Sec-WebSocket-Accept:&nbsp;&quot;&nbsp;.&nbsp;$this-&gt;calcKey($key)&nbsp;.&nbsp;&quot;\r\n\r\n&quot;;&nbsp;&nbsp;//必须以两个回车结尾
&nbsp;&nbsp;&nbsp;&nbsp;$this-&gt;log($upgrade);
&nbsp;&nbsp;&nbsp;&nbsp;$sent&nbsp;=&nbsp;socket_write($socket,&nbsp;$upgrade,&nbsp;strlen($upgrade));
&nbsp;&nbsp;&nbsp;&nbsp;$this-&gt;handshake=true;
&nbsp;&nbsp;&nbsp;&nbsp;$this-&gt;log(&quot;Done&nbsp;handshaking...&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;true;
&nbsp;&nbsp;}

&nbsp;&nbsp;function&nbsp;&nbsp;doResponse($socket&nbsp;,&nbsp;$data)
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$this-&gt;log(&quot;\ndoResponse&nbsp;...&quot;);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$upgrade&nbsp;=&nbsp;&quot;\r\n\r\n&quot;.$data;&nbsp;//&nbsp;curl&nbsp;返回的数据必须在前面有两个&nbsp;回车换行
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$this-&gt;log($upgrade);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$sent&nbsp;=&nbsp;socket_write($socket,&nbsp;$upgrade,&nbsp;strlen($upgrade));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;true;
&nbsp;&nbsp;&nbsp;&nbsp;}

&nbsp;&nbsp;function&nbsp;getHeaders($req){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;$this-&gt;parseHandShake($req);
&nbsp;&nbsp;}

&nbsp;&nbsp;function&nbsp;calcKey($key){
&nbsp;&nbsp;&nbsp;&nbsp;//基于websocket&nbsp;version&nbsp;13
&nbsp;&nbsp;&nbsp;&nbsp;$accept&nbsp;=&nbsp;base64_encode(sha1($key&nbsp;.&nbsp;&#39;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&#39;,&nbsp;true));
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;$accept;
&nbsp;&nbsp;}

&nbsp;&nbsp;function&nbsp;decode($buffer)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;$len&nbsp;=&nbsp;$masks&nbsp;=&nbsp;$data&nbsp;=&nbsp;$decoded&nbsp;=&nbsp;null;
&nbsp;&nbsp;&nbsp;&nbsp;$len&nbsp;=&nbsp;ord($buffer[1])&nbsp;&amp;&nbsp;127;

&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;($len&nbsp;===&nbsp;126)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$masks&nbsp;=&nbsp;substr($buffer,&nbsp;4,&nbsp;4);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$data&nbsp;=&nbsp;substr($buffer,&nbsp;8);
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;if&nbsp;($len&nbsp;===&nbsp;127)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$masks&nbsp;=&nbsp;substr($buffer,&nbsp;10,&nbsp;4);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$data&nbsp;=&nbsp;substr($buffer,&nbsp;14);
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$masks&nbsp;=&nbsp;substr($buffer,&nbsp;2,&nbsp;4);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$data&nbsp;=&nbsp;substr($buffer,&nbsp;6);
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;($index&nbsp;=&nbsp;0;&nbsp;$index&nbsp;&lt;&nbsp;strlen($data);&nbsp;$index++)&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$decoded&nbsp;.=&nbsp;$data[$index]&nbsp;^&nbsp;$masks[$index&nbsp;%&nbsp;4];
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;$decoded;
&nbsp;&nbsp;}

&nbsp;&nbsp;function&nbsp;frame($s){
&nbsp;&nbsp;&nbsp;&nbsp;$a&nbsp;=&nbsp;str_split($s,&nbsp;125);
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(count($a)&nbsp;==&nbsp;1){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&quot;\x81&quot;&nbsp;.&nbsp;chr(strlen($a[0]))&nbsp;.&nbsp;$a[0];
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;$ns&nbsp;=&nbsp;&quot;&quot;;
&nbsp;&nbsp;&nbsp;&nbsp;foreach&nbsp;($a&nbsp;as&nbsp;$o){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$ns&nbsp;.=&nbsp;&quot;\x81&quot;&nbsp;.&nbsp;chr(strlen($o))&nbsp;.&nbsp;$o;
&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;$ns;
&nbsp;&nbsp;}

public&nbsp;static&nbsp;function&nbsp;encode($buffer)&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$len&nbsp;=&nbsp;strlen($buffer);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;if($len&lt;=125)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&quot;\x81&quot;.chr($len).$buffer;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;if($len&lt;=65535)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&quot;\x81&quot;.chr(126).pack(&quot;n&quot;,&nbsp;$len).$buffer;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&quot;\x81&quot;.char(127).pack(&quot;xxxxN&quot;,&nbsp;$len).$buffer;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}


&nbsp;&nbsp;
&nbsp;&nbsp;function&nbsp;say($msg&nbsp;=&nbsp;&quot;&quot;){
&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;$msg&nbsp;.&nbsp;&quot;\n&quot;;
&nbsp;&nbsp;}
&nbsp;&nbsp;function&nbsp;log($msg&nbsp;=&nbsp;&quot;&quot;){
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;($this-&gt;debug){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo&nbsp;$msg&nbsp;.&nbsp;&quot;\n&quot;;
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;
&nbsp;&nbsp;}
}

//定义数据格式&nbsp;&nbsp;类型&nbsp;&nbsp;消息组
//
//[&#39;type&#39;=&gt;&#39;info&#39;,&nbsp;&quot;group&quot;=&gt;&#39;&#39;&nbsp;,&nbsp;&#39;data&#39;=&gt;&#39;&#39;&nbsp;,&nbsp;&#39;contentType&#39;&nbsp;=&gt;&quot;json/text&quot;]&nbsp;;
//$msgType&nbsp;=[&nbsp;&#39;info&#39;&nbsp;,&nbsp;&#39;waring&#39;&nbsp;,&nbsp;&#39;error&#39;&nbsp;&nbsp;];
//{&quot;type&quot;:&quot;info&quot;,&quot;group&quot;:&quot;&quot;,&quot;contentType&quot;:&quot;json&quot;,&quot;data&quot;:{&quot;name&quot;:&quot;12313&quot;}}

new&nbsp;WS(&#39;0.0.0.0&#39;,&nbsp;4000);</pre><p><br/></p>";s:7:"picture";s:0:"";s:11:"createdtime";s:10:"1499055901";s:8:"category";s:9:"1000,1111";s:7:"chapter";s:14:"4200,4222,4225";s:8:"nickname";s:5:"gw123";s:6:"avatar";s:26:"/images/default/avatar.png";s:8:"desc_len";s:1:"0";s:8:"body_len";s:4:"3640";s:10:"status_len";s:1:"1";s:11:"createdTime";s:10:"1499055901";s:6:"userId";s:1:"1";}i:9;a:20:{s:2:"id";s:3:"254";s:2:"pv";s:2:"16";s:10:"collectnum";s:1:"0";s:5:"title";s:34:"Python 局部变量和全局变量";s:6:"userid";s:1:"1";s:8:"promoted";s:1:"1";s:10:"categoryid";s:1:"0";s:4:"desc";s:0:"";s:4:"body";s:4964:"<p>总结：<br/></p><ol class=" list-paddingleft-2"><li><p>内部函数，不修改全局变量可以访问全局变量</p></li><li><p>内部函数，修改同名全局变量，则python会认为它是一个局部变量</p></li><li><p>在内部函数修改同名全局变量之前调用变量名称（如print sum），则引发<span class="link_title">Unbound-LocalError<br/></span></p></li></ol><p>在程序中设置的sum属于全局变量,而在函数中没有sum的定义,根据python访问局部变量和全局变量的规则：当搜索一个变量的时候，python先从局部作用域开始搜索，如果在局部作用域没有找到那个变量，那样python就在全局变量中找这个变量，如果找不到抛出异常(NAMEERROR或者Unbound-LocalError，这取决于python版本。)<br/><br/>如果内部函数有引用外部函数的同名变量或者全局变量,并且对这个变量有修改.那么python会认为它是一个局部变量,又因为函数中没有sum的定义和赋值，所以报错。<br/><br/>从下面两个程序看单独的访问或者修改全局变量，并不报错~<br/><br/>#访问全局变量<br/>#!/usr/bin/python<br/>import<strong>sys</strong><br/>sum=<strong>5</strong><br/><strong>def</strong><strong>add</strong>(a=<strong>1</strong>,b=<strong>3</strong>):<br/>&nbsp; &nbsp;&nbsp;<strong>print</strong>a,b<br/>&nbsp; &nbsp;&nbsp;<strong>print</strong>&nbsp;sum&nbsp; #仅仅访问&nbsp;<br/>add(<strong>4</strong>,<strong>8</strong>)<br/><strong>print</strong>sum<br/>[root<strong>@rac3</strong>python]# python local.py<br/><strong>4</strong><strong>8</strong><br/><strong>5</strong><br/>5<br/><br/>#修改同名的全局变量，则认为是一个局部变量<br/>#!/usr/bin/python<br/>import<strong>sys</strong><br/>sum=<strong>5</strong><br/><strong>def</strong><strong>add</strong>(a=<strong>1</strong>,b=<strong>3</strong>):<br/>&nbsp; &nbsp;&nbsp;<strong>print</strong>&nbsp;a,b<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #<span class="link_title">内部函数有引用外部函数的同名变量或者全局变量,并且对这个变量有修改.那么python会认为它是一个局部变量<br/>&nbsp; &nbsp;&nbsp;sum=b+a&nbsp;#在函数内部修改<br/>&nbsp; &nbsp;&nbsp;<strong>print</strong>&nbsp;sum<br/>add(<strong>4</strong>,<strong>8</strong>)<br/>[root<strong>@rac3</strong>python]# python local.py<br/><strong>4 8</strong><br/><strong>12</strong><br/>下面的程序就会因为“如果内部函数有引用外部函数的同名变量或者全局变量,并且对这个变量有修改.那么python会认为它是一个局部变量,又因为函数中没有sum的定义和赋值，所以报错<br/>#!/usr/bin/python<br/>import<strong>&nbsp;sys</strong><br/>sum=<strong>5</strong><br/><strong>def</strong><strong>add</strong>(a=<strong>1</strong>,b=<strong>3</strong>):<br/>&nbsp; &nbsp;&nbsp;<strong>print</strong>&nbsp;a,b<br/>&nbsp; &nbsp;&nbsp;<strong>print</strong>sum&nbsp; #内部函数引用同名变量，并且修改这个变量。python会认为它是局部变量。因为在此处print之前，没有定义sum变量，所以会报错（建议与情况一比较，备注：此处只是比上例先print sum）<br/>&nbsp; &nbsp;&nbsp;sum=b+a<br/>&nbsp; &nbsp;&nbsp;<strong>print</strong>sum<br/>add(<strong>4</strong>,<strong>8</strong>)<br/><strong>print</strong>&nbsp;sum<br/>[root<strong>@rac3</strong>python]# python local.py<br/><strong>4</strong><strong>8</strong><br/>Traceback(mostrecentcalllast):<br/>&nbsp;File&quot;local.py&quot;,line<strong>10</strong>,<strong>in</strong>?<br/>&nbsp; &nbsp;add(<strong>4</strong>,<strong>8</strong>)<br/>&nbsp;File&quot;local.py&quot;,line<strong>6</strong>,<strong>in</strong>add<br/>&nbsp; &nbsp;<strong>print</strong>sum<br/><strong>UnboundLocalError</strong>:localvariable&#39;sum&#39;referencedbeforeassignment<br/><br/>遇到在程序中访问全局变量并且要修改全局变量的值的情况可以使用：<strong>global</strong>关键字，在函数中声明此变量是全局变量<br/>#!/usr/bin/python<br/>import<strong>sys</strong><br/>sum=<strong>5</strong><br/><strong>print</strong>&#39;改变之前：sum=&#39;,sum<br/><strong>def</strong><strong>add</strong>(a=<strong>1</strong>,b=<strong>3</strong>):<br/>&nbsp; &nbsp;&nbsp;<strong>global</strong>sum<br/>&nbsp; &nbsp;&nbsp;<strong>print</strong>&#39;add 函数中:sum=&#39;,sum<br/>&nbsp; &nbsp;&nbsp;sum=b+a<br/>&nbsp; &nbsp;&nbsp;<strong>print</strong>&#39;函数中改变之后:sum= &#39;,sum<br/>add(<strong>4</strong>,<strong>8</strong>)<br/><strong>print</strong>&#39;改变之后 sum=&#39;,sum<br/>[root<strong>@rac3</strong>python]# vim local.py<br/>改变之前：sum=<strong>5</strong><br/>add函数中:sum=<strong>5</strong><br/>函数中改变之后:sum=&nbsp;<strong>12</strong><br/>改变之后sum=<strong>12</strong></span></p><p><strong>&nbsp;转自&nbsp;http://blog.csdn.net/my2010sam/article/details/17735159</strong></p><p><br/></p>";s:7:"picture";s:0:"";s:11:"createdtime";s:10:"1499074539";s:8:"category";s:9:"1000,1116";s:7:"chapter";s:14:"4400,4401,4409";s:8:"nickname";s:5:"gw123";s:6:"avatar";s:26:"/images/default/avatar.png";s:8:"desc_len";s:1:"0";s:8:"body_len";s:4:"1154";s:10:"status_len";s:1:"1";s:11:"createdTime";s:10:"1499074539";s:6:"userId";s:1:"1";}}i:1;N;}